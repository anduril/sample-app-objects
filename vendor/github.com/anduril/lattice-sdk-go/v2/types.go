// Code generated by Fern. DO NOT EDIT.

package Lattice

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/anduril/lattice-sdk-go/v2/internal"
	time "time"
)

type AcmDetails struct {
	AcmType *AcmDetailsAcmType `json:"acmType,omitempty" url:"acmType,omitempty"`
	// Used for loosely typed associations, such as assignment to a specific fires unit.
	//
	//	Limit to 150 characters.
	AcmDescription *string `json:"acmDescription,omitempty" url:"acmDescription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AcmDetails) GetAcmType() *AcmDetailsAcmType {
	if a == nil {
		return nil
	}
	return a.AcmType
}

func (a *AcmDetails) GetAcmDescription() *string {
	if a == nil {
		return nil
	}
	return a.AcmDescription
}

func (a *AcmDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AcmDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AcmDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcmDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcmDetails) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AcmDetailsAcmType string

const (
	AcmDetailsAcmTypeAcmDetailTypeInvalid     AcmDetailsAcmType = "ACM_DETAIL_TYPE_INVALID"
	AcmDetailsAcmTypeAcmDetailTypeLandingZone AcmDetailsAcmType = "ACM_DETAIL_TYPE_LANDING_ZONE"
)

func NewAcmDetailsAcmTypeFromString(s string) (AcmDetailsAcmType, error) {
	switch s {
	case "ACM_DETAIL_TYPE_INVALID":
		return AcmDetailsAcmTypeAcmDetailTypeInvalid, nil
	case "ACM_DETAIL_TYPE_LANDING_ZONE":
		return AcmDetailsAcmTypeAcmDetailTypeLandingZone, nil
	}
	var t AcmDetailsAcmType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AcmDetailsAcmType) Ptr() *AcmDetailsAcmType {
	return &a
}

// A target relationship is the inverse of TrackedBy; a one-way relation
//
//	from sensor to target, indicating track(s) currently prioritized by a robot.
type ActiveTarget struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActiveTarget) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActiveTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler ActiveTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActiveTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActiveTarget) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents an Agent in the COP.
type Agent struct {
	// Entity ID of the agent.
	EntityID *string `json:"entityId,omitempty" url:"entityId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Agent) GetEntityID() *string {
	if a == nil {
		return nil
	}
	return a.EntityID
}

func (a *Agent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Agent) UnmarshalJSON(data []byte) error {
	type unmarshaler Agent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Agent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Agent) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// An alert informs operators of critical events related to system performance and mission
//
//	execution. An alert is produced as a result of one or more alert conditions.
type Alert struct {
	// Short, machine-readable code that describes this alert. This code is intended to provide systems off-asset
	//
	//	with a lookup key to retrieve more detailed information about the alert.
	AlertCode *string `json:"alertCode,omitempty" url:"alertCode,omitempty"`
	// Human-readable description of this alert. The description is intended for display in the UI for human
	//
	//	understanding and should not be used for machine processing. If the description is fixed and the vehicle controller
	//	provides no dynamic substitutions, then prefer lookup based on alert_code.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Alert level (Warning, Caution, or Advisory).
	Level *AlertLevel `json:"level,omitempty" url:"level,omitempty"`
	// Time at which this alert was activated.
	ActivatedTime *time.Time `json:"activatedTime,omitempty" url:"activatedTime,omitempty"`
	// Set of conditions which have activated this alert.
	ActiveConditions []*AlertCondition `json:"activeConditions,omitempty" url:"activeConditions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Alert) GetAlertCode() *string {
	if a == nil {
		return nil
	}
	return a.AlertCode
}

func (a *Alert) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *Alert) GetLevel() *AlertLevel {
	if a == nil {
		return nil
	}
	return a.Level
}

func (a *Alert) GetActivatedTime() *time.Time {
	if a == nil {
		return nil
	}
	return a.ActivatedTime
}

func (a *Alert) GetActiveConditions() []*AlertCondition {
	if a == nil {
		return nil
	}
	return a.ActiveConditions
}

func (a *Alert) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Alert) UnmarshalJSON(data []byte) error {
	type embed Alert
	var unmarshaler = struct {
		embed
		ActivatedTime *internal.DateTime `json:"activatedTime,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Alert(unmarshaler.embed)
	a.ActivatedTime = unmarshaler.ActivatedTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Alert) MarshalJSON() ([]byte, error) {
	type embed Alert
	var marshaler = struct {
		embed
		ActivatedTime *internal.DateTime `json:"activatedTime,omitempty"`
	}{
		embed:         embed(*a),
		ActivatedTime: internal.NewOptionalDateTime(a.ActivatedTime),
	}
	return json.Marshal(marshaler)
}

func (a *Alert) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// A condition which may trigger an alert.
type AlertCondition struct {
	// Short, machine-readable code that describes this condition. This code is intended to provide systems off-asset
	//
	//	with a lookup key to retrieve more detailed information about the condition.
	ConditionCode *string `json:"conditionCode,omitempty" url:"conditionCode,omitempty"`
	// Human-readable description of this condition. The description is intended for display in the UI for human
	//
	//	understanding and should not be used for machine processing. If the description is fixed and the vehicle controller
	//	provides no dynamic substitutions, then prefer lookup based on condition_code.
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AlertCondition) GetConditionCode() *string {
	if a == nil {
		return nil
	}
	return a.ConditionCode
}

func (a *AlertCondition) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *AlertCondition) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AlertCondition) UnmarshalJSON(data []byte) error {
	type unmarshaler AlertCondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AlertCondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AlertCondition) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Alert level (Warning, Caution, or Advisory).
type AlertLevel string

const (
	AlertLevelAlertLevelInvalid  AlertLevel = "ALERT_LEVEL_INVALID"
	AlertLevelAlertLevelAdvisory AlertLevel = "ALERT_LEVEL_ADVISORY"
	AlertLevelAlertLevelCaution  AlertLevel = "ALERT_LEVEL_CAUTION"
	AlertLevelAlertLevelWarning  AlertLevel = "ALERT_LEVEL_WARNING"
)

func NewAlertLevelFromString(s string) (AlertLevel, error) {
	switch s {
	case "ALERT_LEVEL_INVALID":
		return AlertLevelAlertLevelInvalid, nil
	case "ALERT_LEVEL_ADVISORY":
		return AlertLevelAlertLevelAdvisory, nil
	case "ALERT_LEVEL_CAUTION":
		return AlertLevelAlertLevelCaution, nil
	case "ALERT_LEVEL_WARNING":
		return AlertLevelAlertLevelWarning, nil
	}
	var t AlertLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AlertLevel) Ptr() *AlertLevel {
	return &a
}

// Available for any Entities with alternate ids in other systems.
type Aliases struct {
	AlternateIDs []*AlternateID `json:"alternateIds,omitempty" url:"alternateIds,omitempty"`
	// The best available version of the entity's display name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Aliases) GetAlternateIDs() []*AlternateID {
	if a == nil {
		return nil
	}
	return a.AlternateIDs
}

func (a *Aliases) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *Aliases) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Aliases) UnmarshalJSON(data []byte) error {
	type unmarshaler Aliases
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Aliases(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Aliases) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// An alternate id for an Entity.
type AlternateID struct {
	ID   *string          `json:"id,omitempty" url:"id,omitempty"`
	Type *AlternateIDType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AlternateID) GetID() *string {
	if a == nil {
		return nil
	}
	return a.ID
}

func (a *AlternateID) GetType() *AlternateIDType {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *AlternateID) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AlternateID) UnmarshalJSON(data []byte) error {
	type unmarshaler AlternateID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AlternateID(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AlternateID) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AlternateIDType string

const (
	AlternateIDTypeAltIDTypeInvalid           AlternateIDType = "ALT_ID_TYPE_INVALID"
	AlternateIDTypeAltIDTypeTrackID2          AlternateIDType = "ALT_ID_TYPE_TRACK_ID_2"
	AlternateIDTypeAltIDTypeTrackID1          AlternateIDType = "ALT_ID_TYPE_TRACK_ID_1"
	AlternateIDTypeAltIDTypeSpiID             AlternateIDType = "ALT_ID_TYPE_SPI_ID"
	AlternateIDTypeAltIDTypeNitfFileTitle     AlternateIDType = "ALT_ID_TYPE_NITF_FILE_TITLE"
	AlternateIDTypeAltIDTypeTrackRepoAlertID  AlternateIDType = "ALT_ID_TYPE_TRACK_REPO_ALERT_ID"
	AlternateIDTypeAltIDTypeAssetID           AlternateIDType = "ALT_ID_TYPE_ASSET_ID"
	AlternateIDTypeAltIDTypeLink16TrackNumber AlternateIDType = "ALT_ID_TYPE_LINK16_TRACK_NUMBER"
	AlternateIDTypeAltIDTypeLink16Ju          AlternateIDType = "ALT_ID_TYPE_LINK16_JU"
	AlternateIDTypeAltIDTypeNcctMessageID     AlternateIDType = "ALT_ID_TYPE_NCCT_MESSAGE_ID"
	AlternateIDTypeAltIDTypeCallsign          AlternateIDType = "ALT_ID_TYPE_CALLSIGN"
	AlternateIDTypeAltIDTypeMmsiID            AlternateIDType = "ALT_ID_TYPE_MMSI_ID"
	AlternateIDTypeAltIDTypeVmfUrn            AlternateIDType = "ALT_ID_TYPE_VMF_URN"
	AlternateIDTypeAltIDTypeImoID             AlternateIDType = "ALT_ID_TYPE_IMO_ID"
	AlternateIDTypeAltIDTypeVmfTargetNumber   AlternateIDType = "ALT_ID_TYPE_VMF_TARGET_NUMBER"
	AlternateIDTypeAltIDTypeSerialNumber      AlternateIDType = "ALT_ID_TYPE_SERIAL_NUMBER"
	AlternateIDTypeAltIDTypeRegistrationID    AlternateIDType = "ALT_ID_TYPE_REGISTRATION_ID"
	AlternateIDTypeAltIDTypeIbsGid            AlternateIDType = "ALT_ID_TYPE_IBS_GID"
	AlternateIDTypeAltIDTypeDodaac            AlternateIDType = "ALT_ID_TYPE_DODAAC"
	AlternateIDTypeAltIDTypeUic               AlternateIDType = "ALT_ID_TYPE_UIC"
	AlternateIDTypeAltIDTypeNoradCatID        AlternateIDType = "ALT_ID_TYPE_NORAD_CAT_ID"
	AlternateIDTypeAltIDTypeUnoosaName        AlternateIDType = "ALT_ID_TYPE_UNOOSA_NAME"
	AlternateIDTypeAltIDTypeUnoosaID          AlternateIDType = "ALT_ID_TYPE_UNOOSA_ID"
)

func NewAlternateIDTypeFromString(s string) (AlternateIDType, error) {
	switch s {
	case "ALT_ID_TYPE_INVALID":
		return AlternateIDTypeAltIDTypeInvalid, nil
	case "ALT_ID_TYPE_TRACK_ID_2":
		return AlternateIDTypeAltIDTypeTrackID2, nil
	case "ALT_ID_TYPE_TRACK_ID_1":
		return AlternateIDTypeAltIDTypeTrackID1, nil
	case "ALT_ID_TYPE_SPI_ID":
		return AlternateIDTypeAltIDTypeSpiID, nil
	case "ALT_ID_TYPE_NITF_FILE_TITLE":
		return AlternateIDTypeAltIDTypeNitfFileTitle, nil
	case "ALT_ID_TYPE_TRACK_REPO_ALERT_ID":
		return AlternateIDTypeAltIDTypeTrackRepoAlertID, nil
	case "ALT_ID_TYPE_ASSET_ID":
		return AlternateIDTypeAltIDTypeAssetID, nil
	case "ALT_ID_TYPE_LINK16_TRACK_NUMBER":
		return AlternateIDTypeAltIDTypeLink16TrackNumber, nil
	case "ALT_ID_TYPE_LINK16_JU":
		return AlternateIDTypeAltIDTypeLink16Ju, nil
	case "ALT_ID_TYPE_NCCT_MESSAGE_ID":
		return AlternateIDTypeAltIDTypeNcctMessageID, nil
	case "ALT_ID_TYPE_CALLSIGN":
		return AlternateIDTypeAltIDTypeCallsign, nil
	case "ALT_ID_TYPE_MMSI_ID":
		return AlternateIDTypeAltIDTypeMmsiID, nil
	case "ALT_ID_TYPE_VMF_URN":
		return AlternateIDTypeAltIDTypeVmfUrn, nil
	case "ALT_ID_TYPE_IMO_ID":
		return AlternateIDTypeAltIDTypeImoID, nil
	case "ALT_ID_TYPE_VMF_TARGET_NUMBER":
		return AlternateIDTypeAltIDTypeVmfTargetNumber, nil
	case "ALT_ID_TYPE_SERIAL_NUMBER":
		return AlternateIDTypeAltIDTypeSerialNumber, nil
	case "ALT_ID_TYPE_REGISTRATION_ID":
		return AlternateIDTypeAltIDTypeRegistrationID, nil
	case "ALT_ID_TYPE_IBS_GID":
		return AlternateIDTypeAltIDTypeIbsGid, nil
	case "ALT_ID_TYPE_DODAAC":
		return AlternateIDTypeAltIDTypeDodaac, nil
	case "ALT_ID_TYPE_UIC":
		return AlternateIDTypeAltIDTypeUic, nil
	case "ALT_ID_TYPE_NORAD_CAT_ID":
		return AlternateIDTypeAltIDTypeNoradCatID, nil
	case "ALT_ID_TYPE_UNOOSA_NAME":
		return AlternateIDTypeAltIDTypeUnoosaName, nil
	case "ALT_ID_TYPE_UNOOSA_ID":
		return AlternateIDTypeAltIDTypeUnoosaID, nil
	}
	var t AlternateIDType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AlternateIDType) Ptr() *AlternateIDType {
	return &a
}

// The direction from which the signal is received
type AngleOfArrival struct {
	// Origin (LLA) and attitude (relative to ENU) of a ray pointing towards the detection. The attitude represents a
	//
	//	forward-left-up (FLU) frame where the x-axis (1, 0, 0) is pointing towards the target.
	RelativePose *Pose `json:"relativePose,omitempty" url:"relativePose,omitempty"`
	// Bearing/elevation covariance matrix where bearing is defined in radians CCW+ about the z-axis from the x-axis of FLU frame
	//
	//	and elevation is positive down from the FL/XY plane.
	//	mxx = bearing variance in rad^2
	//	mxy = bearing/elevation covariance in rad^2
	//	myy = elevation variance in rad^2
	BearingElevationCovarianceRad2 *TMat2 `json:"bearingElevationCovarianceRad2,omitempty" url:"bearingElevationCovarianceRad2,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AngleOfArrival) GetRelativePose() *Pose {
	if a == nil {
		return nil
	}
	return a.RelativePose
}

func (a *AngleOfArrival) GetBearingElevationCovarianceRad2() *TMat2 {
	if a == nil {
		return nil
	}
	return a.BearingElevationCovarianceRad2
}

func (a *AngleOfArrival) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AngleOfArrival) UnmarshalJSON(data []byte) error {
	type unmarshaler AngleOfArrival
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AngleOfArrival(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AngleOfArrival) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Describes the bandwidth of a signal
type Bandwidth struct {
	BandwidthHz *float64 `json:"bandwidthHz,omitempty" url:"bandwidthHz,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Bandwidth) GetBandwidthHz() *float64 {
	if b == nil {
		return nil
	}
	return b.BandwidthHz
}

func (b *Bandwidth) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Bandwidth) UnmarshalJSON(data []byte) error {
	type unmarshaler Bandwidth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Bandwidth(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Bandwidth) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A component that describes the min and max bandwidths of a sensor
type BandwidthRange struct {
	MinimumBandwidth *Bandwidth `json:"minimumBandwidth,omitempty" url:"minimumBandwidth,omitempty"`
	MaximumBandwidth *Bandwidth `json:"maximumBandwidth,omitempty" url:"maximumBandwidth,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BandwidthRange) GetMinimumBandwidth() *Bandwidth {
	if b == nil {
		return nil
	}
	return b.MinimumBandwidth
}

func (b *BandwidthRange) GetMaximumBandwidth() *Bandwidth {
	if b == nil {
		return nil
	}
	return b.MaximumBandwidth
}

func (b *BandwidthRange) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BandwidthRange) UnmarshalJSON(data []byte) error {
	type unmarshaler BandwidthRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BandwidthRange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BandwidthRange) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A component that describes an entity's security classification levels.
type Classification struct {
	// The default classification information which should be assumed to apply to everything in
	//
	//	the entity unless a specific field level classification is present.
	Default *ClassificationInformation `json:"default,omitempty" url:"default,omitempty"`
	// The set of individual field classification information which should always precedence
	//
	//	over the default classification information.
	Fields []*FieldClassificationInformation `json:"fields,omitempty" url:"fields,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Classification) GetDefault() *ClassificationInformation {
	if c == nil {
		return nil
	}
	return c.Default
}

func (c *Classification) GetFields() []*FieldClassificationInformation {
	if c == nil {
		return nil
	}
	return c.Fields
}

func (c *Classification) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Classification) UnmarshalJSON(data []byte) error {
	type unmarshaler Classification
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Classification(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Classification) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents all of the necessary information required to generate a summarized
//
//	classification marking.
//
//	> example: A summarized classification marking of "TOPSECRET//NOFORN//FISA"
//	           would be defined as: { "level": 5, "caveats": [ "NOFORN, "FISA" ] }
type ClassificationInformation struct {
	// Classification level to be applied to the information in question.
	Level *ClassificationInformationLevel `json:"level,omitempty" url:"level,omitempty"`
	// Caveats that may further restrict how the information can be disseminated.
	Caveats []string `json:"caveats,omitempty" url:"caveats,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClassificationInformation) GetLevel() *ClassificationInformationLevel {
	if c == nil {
		return nil
	}
	return c.Level
}

func (c *ClassificationInformation) GetCaveats() []string {
	if c == nil {
		return nil
	}
	return c.Caveats
}

func (c *ClassificationInformation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClassificationInformation) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassificationInformation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassificationInformation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassificationInformation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Classification level to be applied to the information in question.
type ClassificationInformationLevel string

const (
	ClassificationInformationLevelClassificationLevelsInvalid                ClassificationInformationLevel = "CLASSIFICATION_LEVELS_INVALID"
	ClassificationInformationLevelClassificationLevelsUnclassified           ClassificationInformationLevel = "CLASSIFICATION_LEVELS_UNCLASSIFIED"
	ClassificationInformationLevelClassificationLevelsControlledUnclassified ClassificationInformationLevel = "CLASSIFICATION_LEVELS_CONTROLLED_UNCLASSIFIED"
	ClassificationInformationLevelClassificationLevelsConfidential           ClassificationInformationLevel = "CLASSIFICATION_LEVELS_CONFIDENTIAL"
	ClassificationInformationLevelClassificationLevelsSecret                 ClassificationInformationLevel = "CLASSIFICATION_LEVELS_SECRET"
	ClassificationInformationLevelClassificationLevelsTopSecret              ClassificationInformationLevel = "CLASSIFICATION_LEVELS_TOP_SECRET"
)

func NewClassificationInformationLevelFromString(s string) (ClassificationInformationLevel, error) {
	switch s {
	case "CLASSIFICATION_LEVELS_INVALID":
		return ClassificationInformationLevelClassificationLevelsInvalid, nil
	case "CLASSIFICATION_LEVELS_UNCLASSIFIED":
		return ClassificationInformationLevelClassificationLevelsUnclassified, nil
	case "CLASSIFICATION_LEVELS_CONTROLLED_UNCLASSIFIED":
		return ClassificationInformationLevelClassificationLevelsControlledUnclassified, nil
	case "CLASSIFICATION_LEVELS_CONFIDENTIAL":
		return ClassificationInformationLevelClassificationLevelsConfidential, nil
	case "CLASSIFICATION_LEVELS_SECRET":
		return ClassificationInformationLevelClassificationLevelsSecret, nil
	case "CLASSIFICATION_LEVELS_TOP_SECRET":
		return ClassificationInformationLevelClassificationLevelsTopSecret, nil
	}
	var t ClassificationInformationLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClassificationInformationLevel) Ptr() *ClassificationInformationLevel {
	return &c
}

type Color struct {
	// The amount of red in the color as a value in the interval [0, 1].
	Red *float64 `json:"red,omitempty" url:"red,omitempty"`
	// The amount of green in the color as a value in the interval [0, 1].
	Green *float64 `json:"green,omitempty" url:"green,omitempty"`
	// The amount of blue in the color as a value in the interval [0, 1].
	Blue *float64 `json:"blue,omitempty" url:"blue,omitempty"`
	// The fraction of this color that should be applied to the pixel. That is,
	//
	//	the final pixel color is defined by the equation:
	//
	//	`pixel color = alpha * (this color) + (1.0 - alpha) * (background color)`
	//
	//	This means that a value of 1.0 corresponds to a solid color, whereas
	//	a value of 0.0 corresponds to a completely transparent color. This
	//	uses a wrapper message rather than a simple float scalar so that it is
	//	possible to distinguish between a default value and the value being unset.
	//	If omitted, this color object is rendered as a solid color
	//	(as if the alpha value had been explicitly given a value of 1.0).
	Alpha *float64 `json:"alpha,omitempty" url:"alpha,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Color) GetRed() *float64 {
	if c == nil {
		return nil
	}
	return c.Red
}

func (c *Color) GetGreen() *float64 {
	if c == nil {
		return nil
	}
	return c.Green
}

func (c *Color) GetBlue() *float64 {
	if c == nil {
		return nil
	}
	return c.Blue
}

func (c *Color) GetAlpha() *float64 {
	if c == nil {
		return nil
	}
	return c.Alpha
}

func (c *Color) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Color) UnmarshalJSON(data []byte) error {
	type unmarshaler Color
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Color(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Color) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Health of an individual component.
type ComponentHealth struct {
	// Consistent internal ID for this component.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Display name for this component.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Health for this component.
	Health *ComponentHealthHealth `json:"health,omitempty" url:"health,omitempty"`
	// Human-readable describing the component state. These messages should be understandable by end users.
	Messages []*ComponentMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// The last update time for this specific component.
	//
	//	If this timestamp is unset, the data is assumed to be most recent
	UpdateTime *time.Time `json:"updateTime,omitempty" url:"updateTime,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ComponentHealth) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ComponentHealth) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ComponentHealth) GetHealth() *ComponentHealthHealth {
	if c == nil {
		return nil
	}
	return c.Health
}

func (c *ComponentHealth) GetMessages() []*ComponentMessage {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *ComponentHealth) GetUpdateTime() *time.Time {
	if c == nil {
		return nil
	}
	return c.UpdateTime
}

func (c *ComponentHealth) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ComponentHealth) UnmarshalJSON(data []byte) error {
	type embed ComponentHealth
	var unmarshaler = struct {
		embed
		UpdateTime *internal.DateTime `json:"updateTime,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ComponentHealth(unmarshaler.embed)
	c.UpdateTime = unmarshaler.UpdateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ComponentHealth) MarshalJSON() ([]byte, error) {
	type embed ComponentHealth
	var marshaler = struct {
		embed
		UpdateTime *internal.DateTime `json:"updateTime,omitempty"`
	}{
		embed:      embed(*c),
		UpdateTime: internal.NewOptionalDateTime(c.UpdateTime),
	}
	return json.Marshal(marshaler)
}

func (c *ComponentHealth) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Health for this component.
type ComponentHealthHealth string

const (
	ComponentHealthHealthHealthStatusInvalid  ComponentHealthHealth = "HEALTH_STATUS_INVALID"
	ComponentHealthHealthHealthStatusHealthy  ComponentHealthHealth = "HEALTH_STATUS_HEALTHY"
	ComponentHealthHealthHealthStatusWarn     ComponentHealthHealth = "HEALTH_STATUS_WARN"
	ComponentHealthHealthHealthStatusFail     ComponentHealthHealth = "HEALTH_STATUS_FAIL"
	ComponentHealthHealthHealthStatusOffline  ComponentHealthHealth = "HEALTH_STATUS_OFFLINE"
	ComponentHealthHealthHealthStatusNotReady ComponentHealthHealth = "HEALTH_STATUS_NOT_READY"
)

func NewComponentHealthHealthFromString(s string) (ComponentHealthHealth, error) {
	switch s {
	case "HEALTH_STATUS_INVALID":
		return ComponentHealthHealthHealthStatusInvalid, nil
	case "HEALTH_STATUS_HEALTHY":
		return ComponentHealthHealthHealthStatusHealthy, nil
	case "HEALTH_STATUS_WARN":
		return ComponentHealthHealthHealthStatusWarn, nil
	case "HEALTH_STATUS_FAIL":
		return ComponentHealthHealthHealthStatusFail, nil
	case "HEALTH_STATUS_OFFLINE":
		return ComponentHealthHealthHealthStatusOffline, nil
	case "HEALTH_STATUS_NOT_READY":
		return ComponentHealthHealthHealthStatusNotReady, nil
	}
	var t ComponentHealthHealth
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ComponentHealthHealth) Ptr() *ComponentHealthHealth {
	return &c
}

// A message describing the component's health status.
type ComponentMessage struct {
	// The status associated with this message.
	Status *ComponentMessageStatus `json:"status,omitempty" url:"status,omitempty"`
	// The human-readable content of the message.
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ComponentMessage) GetStatus() *ComponentMessageStatus {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *ComponentMessage) GetMessage() *string {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *ComponentMessage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ComponentMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ComponentMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ComponentMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ComponentMessage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The status associated with this message.
type ComponentMessageStatus string

const (
	ComponentMessageStatusHealthStatusInvalid  ComponentMessageStatus = "HEALTH_STATUS_INVALID"
	ComponentMessageStatusHealthStatusHealthy  ComponentMessageStatus = "HEALTH_STATUS_HEALTHY"
	ComponentMessageStatusHealthStatusWarn     ComponentMessageStatus = "HEALTH_STATUS_WARN"
	ComponentMessageStatusHealthStatusFail     ComponentMessageStatus = "HEALTH_STATUS_FAIL"
	ComponentMessageStatusHealthStatusOffline  ComponentMessageStatus = "HEALTH_STATUS_OFFLINE"
	ComponentMessageStatusHealthStatusNotReady ComponentMessageStatus = "HEALTH_STATUS_NOT_READY"
)

func NewComponentMessageStatusFromString(s string) (ComponentMessageStatus, error) {
	switch s {
	case "HEALTH_STATUS_INVALID":
		return ComponentMessageStatusHealthStatusInvalid, nil
	case "HEALTH_STATUS_HEALTHY":
		return ComponentMessageStatusHealthStatusHealthy, nil
	case "HEALTH_STATUS_WARN":
		return ComponentMessageStatusHealthStatusWarn, nil
	case "HEALTH_STATUS_FAIL":
		return ComponentMessageStatusHealthStatusFail, nil
	case "HEALTH_STATUS_OFFLINE":
		return ComponentMessageStatusHealthStatusOffline, nil
	case "HEALTH_STATUS_NOT_READY":
		return ComponentMessageStatusHealthStatusNotReady, nil
	}
	var t ComponentMessageStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ComponentMessageStatus) Ptr() *ComponentMessageStatus {
	return &c
}

// Determines the type of control area being represented by the geo-entity,
//
//	in which an asset can, or cannot, operate.
type ControlAreaDetails struct {
	Type *ControlAreaDetailsType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ControlAreaDetails) GetType() *ControlAreaDetailsType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ControlAreaDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ControlAreaDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ControlAreaDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ControlAreaDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ControlAreaDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ControlAreaDetailsType string

const (
	ControlAreaDetailsTypeControlAreaTypeInvalid     ControlAreaDetailsType = "CONTROL_AREA_TYPE_INVALID"
	ControlAreaDetailsTypeControlAreaTypeKeepInZone  ControlAreaDetailsType = "CONTROL_AREA_TYPE_KEEP_IN_ZONE"
	ControlAreaDetailsTypeControlAreaTypeKeepOutZone ControlAreaDetailsType = "CONTROL_AREA_TYPE_KEEP_OUT_ZONE"
	ControlAreaDetailsTypeControlAreaTypeDitchZone   ControlAreaDetailsType = "CONTROL_AREA_TYPE_DITCH_ZONE"
	ControlAreaDetailsTypeControlAreaTypeLoiterZone  ControlAreaDetailsType = "CONTROL_AREA_TYPE_LOITER_ZONE"
)

func NewControlAreaDetailsTypeFromString(s string) (ControlAreaDetailsType, error) {
	switch s {
	case "CONTROL_AREA_TYPE_INVALID":
		return ControlAreaDetailsTypeControlAreaTypeInvalid, nil
	case "CONTROL_AREA_TYPE_KEEP_IN_ZONE":
		return ControlAreaDetailsTypeControlAreaTypeKeepInZone, nil
	case "CONTROL_AREA_TYPE_KEEP_OUT_ZONE":
		return ControlAreaDetailsTypeControlAreaTypeKeepOutZone, nil
	case "CONTROL_AREA_TYPE_DITCH_ZONE":
		return ControlAreaDetailsTypeControlAreaTypeDitchZone, nil
	case "CONTROL_AREA_TYPE_LOITER_ZONE":
		return ControlAreaDetailsTypeControlAreaTypeLoiterZone, nil
	}
	var t ControlAreaDetailsType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ControlAreaDetailsType) Ptr() *ControlAreaDetailsType {
	return &c
}

// Available for Entities that are a correlated (N to 1) set of entities. This will be present on
//
//	each entity in the set.
type Correlation struct {
	// This entity is the primary of a correlation meaning that it serves as the representative
	//
	//	entity of the correlation set.
	Primary *PrimaryCorrelation `json:"primary,omitempty" url:"primary,omitempty"`
	// This entity is a secondary of a correlation meaning that it will be represented by the
	//
	//	primary of the correlation set.
	Secondary *SecondaryCorrelation `json:"secondary,omitempty" url:"secondary,omitempty"`
	// If present, this entity is a part of a correlation set.
	Membership *CorrelationMembership `json:"membership,omitempty" url:"membership,omitempty"`
	// If present, this entity was explicitly decorrelated from one or more entities.
	//
	//	An entity can be both correlated and decorrelated as long as they are disjoint sets.
	//	An example would be if a user in the UI decides that two tracks are not actually the
	//	same despite an automatic correlator having correlated them. The user would then
	//	decorrelate the two tracks and this decorrelation would be preserved preventing the
	//	correlator from re-correlating them at a later time.
	Decorrelation *Decorrelation `json:"decorrelation,omitempty" url:"decorrelation,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Correlation) GetPrimary() *PrimaryCorrelation {
	if c == nil {
		return nil
	}
	return c.Primary
}

func (c *Correlation) GetSecondary() *SecondaryCorrelation {
	if c == nil {
		return nil
	}
	return c.Secondary
}

func (c *Correlation) GetMembership() *CorrelationMembership {
	if c == nil {
		return nil
	}
	return c.Membership
}

func (c *Correlation) GetDecorrelation() *Decorrelation {
	if c == nil {
		return nil
	}
	return c.Decorrelation
}

func (c *Correlation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Correlation) UnmarshalJSON(data []byte) error {
	type unmarshaler Correlation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Correlation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Correlation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CorrelationMembership struct {
	// The ID of the correlation set this entity belongs to.
	CorrelationSetID *string `json:"correlationSetId,omitempty" url:"correlationSetId,omitempty"`
	// This entity is the primary of a correlation set meaning that it serves as the representative
	//
	//	entity of the correlation set.
	Primary *PrimaryMembership `json:"primary,omitempty" url:"primary,omitempty"`
	// This entity is not the primary of the correlation set. Note that there may not
	//
	//	be a primary at all.
	NonPrimary *NonPrimaryMembership `json:"nonPrimary,omitempty" url:"nonPrimary,omitempty"`
	// Additional metadata on this correlation.
	Metadata *CorrelationMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CorrelationMembership) GetCorrelationSetID() *string {
	if c == nil {
		return nil
	}
	return c.CorrelationSetID
}

func (c *CorrelationMembership) GetPrimary() *PrimaryMembership {
	if c == nil {
		return nil
	}
	return c.Primary
}

func (c *CorrelationMembership) GetNonPrimary() *NonPrimaryMembership {
	if c == nil {
		return nil
	}
	return c.NonPrimary
}

func (c *CorrelationMembership) GetMetadata() *CorrelationMetadata {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CorrelationMembership) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CorrelationMembership) UnmarshalJSON(data []byte) error {
	type unmarshaler CorrelationMembership
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CorrelationMembership(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CorrelationMembership) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CorrelationMetadata struct {
	// Who or what added this entity to the (de)correlation.
	Provenance *Provenance `json:"provenance,omitempty" url:"provenance,omitempty"`
	// Indicates how the correlation will be distributed. Because a correlation is composed of
	//
	//	multiple secondaries, each of which may have been correlated with different replication
	//	modes, the distribution of the correlation is composed of distributions of the individual
	//	entities within the correlation set.
	//	For example, if there are two secondary entities A and B correlated against a primary C,
	//	with A having been correlated globally and B having been correlated locally, then the
	//	correlation set that is distributed globally than what is known locally in the node.
	ReplicationMode *CorrelationMetadataReplicationMode `json:"replicationMode,omitempty" url:"replicationMode,omitempty"`
	// What type of (de)correlation was this entity added with.
	Type *CorrelationMetadataType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CorrelationMetadata) GetProvenance() *Provenance {
	if c == nil {
		return nil
	}
	return c.Provenance
}

func (c *CorrelationMetadata) GetReplicationMode() *CorrelationMetadataReplicationMode {
	if c == nil {
		return nil
	}
	return c.ReplicationMode
}

func (c *CorrelationMetadata) GetType() *CorrelationMetadataType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CorrelationMetadata) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CorrelationMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler CorrelationMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CorrelationMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CorrelationMetadata) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates how the correlation will be distributed. Because a correlation is composed of
//
//	multiple secondaries, each of which may have been correlated with different replication
//	modes, the distribution of the correlation is composed of distributions of the individual
//	entities within the correlation set.
//	For example, if there are two secondary entities A and B correlated against a primary C,
//	with A having been correlated globally and B having been correlated locally, then the
//	correlation set that is distributed globally than what is known locally in the node.
type CorrelationMetadataReplicationMode string

const (
	CorrelationMetadataReplicationModeCorrelationReplicationModeInvalid CorrelationMetadataReplicationMode = "CORRELATION_REPLICATION_MODE_INVALID"
	CorrelationMetadataReplicationModeCorrelationReplicationModeLocal   CorrelationMetadataReplicationMode = "CORRELATION_REPLICATION_MODE_LOCAL"
	CorrelationMetadataReplicationModeCorrelationReplicationModeGlobal  CorrelationMetadataReplicationMode = "CORRELATION_REPLICATION_MODE_GLOBAL"
)

func NewCorrelationMetadataReplicationModeFromString(s string) (CorrelationMetadataReplicationMode, error) {
	switch s {
	case "CORRELATION_REPLICATION_MODE_INVALID":
		return CorrelationMetadataReplicationModeCorrelationReplicationModeInvalid, nil
	case "CORRELATION_REPLICATION_MODE_LOCAL":
		return CorrelationMetadataReplicationModeCorrelationReplicationModeLocal, nil
	case "CORRELATION_REPLICATION_MODE_GLOBAL":
		return CorrelationMetadataReplicationModeCorrelationReplicationModeGlobal, nil
	}
	var t CorrelationMetadataReplicationMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CorrelationMetadataReplicationMode) Ptr() *CorrelationMetadataReplicationMode {
	return &c
}

// What type of (de)correlation was this entity added with.
type CorrelationMetadataType string

const (
	CorrelationMetadataTypeCorrelationTypeInvalid   CorrelationMetadataType = "CORRELATION_TYPE_INVALID"
	CorrelationMetadataTypeCorrelationTypeManual    CorrelationMetadataType = "CORRELATION_TYPE_MANUAL"
	CorrelationMetadataTypeCorrelationTypeAutomated CorrelationMetadataType = "CORRELATION_TYPE_AUTOMATED"
)

func NewCorrelationMetadataTypeFromString(s string) (CorrelationMetadataType, error) {
	switch s {
	case "CORRELATION_TYPE_INVALID":
		return CorrelationMetadataTypeCorrelationTypeInvalid, nil
	case "CORRELATION_TYPE_MANUAL":
		return CorrelationMetadataTypeCorrelationTypeManual, nil
	case "CORRELATION_TYPE_AUTOMATED":
		return CorrelationMetadataTypeCorrelationTypeAutomated, nil
	}
	var t CorrelationMetadataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CorrelationMetadataType) Ptr() *CorrelationMetadataType {
	return &c
}

type CronWindow struct {
	// in UTC, describes when and at what cadence this window starts, in the quartz flavor of cron
	//
	//	examples:
	//	   This schedule is begins at 7:00:00am UTC everyday between Monday and Friday
	//	       0 0 7 ? * MON-FRI *
	//	   This schedule begins every 5 minutes starting at 12:00:00pm UTC until 8:00:00pm UTC everyday
	//	       0 0/5 12-20 * * ? *
	//	   This schedule begins at 12:00:00pm UTC on March 2nd 2023
	//	       0 0 12 2 3 ? 2023
	CronExpression *string `json:"cronExpression,omitempty" url:"cronExpression,omitempty"`
	// describes the duration
	DurationMillis *string `json:"durationMillis,omitempty" url:"durationMillis,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CronWindow) GetCronExpression() *string {
	if c == nil {
		return nil
	}
	return c.CronExpression
}

func (c *CronWindow) GetDurationMillis() *string {
	if c == nil {
		return nil
	}
	return c.DurationMillis
}

func (c *CronWindow) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CronWindow) UnmarshalJSON(data []byte) error {
	type unmarshaler CronWindow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CronWindow(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CronWindow) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DecorrelatedAll struct {
	// Metadata about the decorrelation.
	Metadata *CorrelationMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DecorrelatedAll) GetMetadata() *CorrelationMetadata {
	if d == nil {
		return nil
	}
	return d.Metadata
}

func (d *DecorrelatedAll) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DecorrelatedAll) UnmarshalJSON(data []byte) error {
	type unmarshaler DecorrelatedAll
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DecorrelatedAll(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DecorrelatedAll) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DecorrelatedSingle struct {
	// The entity that was decorrelated against.
	EntityID *string `json:"entityId,omitempty" url:"entityId,omitempty"`
	// Metadata about the decorrelation.
	Metadata *CorrelationMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DecorrelatedSingle) GetEntityID() *string {
	if d == nil {
		return nil
	}
	return d.EntityID
}

func (d *DecorrelatedSingle) GetMetadata() *CorrelationMetadata {
	if d == nil {
		return nil
	}
	return d.Metadata
}

func (d *DecorrelatedSingle) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DecorrelatedSingle) UnmarshalJSON(data []byte) error {
	type unmarshaler DecorrelatedSingle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DecorrelatedSingle(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DecorrelatedSingle) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type Decorrelation struct {
	// This will be specified if this entity was decorrelated against all other entities.
	All *DecorrelatedAll `json:"all,omitempty" url:"all,omitempty"`
	// A list of decorrelated entities that have been explicitly decorrelated against this entity
	//
	//	which prevents lower precedence correlations from overriding it in the future.
	//	For example, if an operator in the UI decorrelated tracks A and B, any automated
	//	correlators would be unable to correlate them since manual decorrelations have
	//	higher precedence than automatic ones. Precedence is determined by both correlation
	//	type and replication mode.
	DecorrelatedEntities []*DecorrelatedSingle `json:"decorrelatedEntities,omitempty" url:"decorrelatedEntities,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *Decorrelation) GetAll() *DecorrelatedAll {
	if d == nil {
		return nil
	}
	return d.All
}

func (d *Decorrelation) GetDecorrelatedEntities() []*DecorrelatedSingle {
	if d == nil {
		return nil
	}
	return d.DecorrelatedEntities
}

func (d *Decorrelation) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Decorrelation) UnmarshalJSON(data []byte) error {
	type unmarshaler Decorrelation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Decorrelation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *Decorrelation) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type Dimensions struct {
	// Length of the entity in meters
	LengthM *float64 `json:"lengthM,omitempty" url:"lengthM,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *Dimensions) GetLengthM() *float64 {
	if d == nil {
		return nil
	}
	return d.LengthM
}

func (d *Dimensions) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Dimensions) UnmarshalJSON(data []byte) error {
	type unmarshaler Dimensions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Dimensions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *Dimensions) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Describes a Echelon group type.  Comprised of entities which are members of the
//
//	same unit or echelon. Ex: A group of tanks within a armored company or that same company
//	as a member of a battalion.
type Echelon struct {
	ArmyEchelon *EchelonArmyEchelon `json:"armyEchelon,omitempty" url:"armyEchelon,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Echelon) GetArmyEchelon() *EchelonArmyEchelon {
	if e == nil {
		return nil
	}
	return e.ArmyEchelon
}

func (e *Echelon) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Echelon) UnmarshalJSON(data []byte) error {
	type unmarshaler Echelon
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Echelon(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Echelon) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EchelonArmyEchelon string

const (
	EchelonArmyEchelonArmyEchelonInvalid   EchelonArmyEchelon = "ARMY_ECHELON_INVALID"
	EchelonArmyEchelonArmyEchelonFireTeam  EchelonArmyEchelon = "ARMY_ECHELON_FIRE_TEAM"
	EchelonArmyEchelonArmyEchelonSquad     EchelonArmyEchelon = "ARMY_ECHELON_SQUAD"
	EchelonArmyEchelonArmyEchelonPlatoon   EchelonArmyEchelon = "ARMY_ECHELON_PLATOON"
	EchelonArmyEchelonArmyEchelonCompany   EchelonArmyEchelon = "ARMY_ECHELON_COMPANY"
	EchelonArmyEchelonArmyEchelonBattalion EchelonArmyEchelon = "ARMY_ECHELON_BATTALION"
	EchelonArmyEchelonArmyEchelonRegiment  EchelonArmyEchelon = "ARMY_ECHELON_REGIMENT"
	EchelonArmyEchelonArmyEchelonBrigade   EchelonArmyEchelon = "ARMY_ECHELON_BRIGADE"
	EchelonArmyEchelonArmyEchelonDivision  EchelonArmyEchelon = "ARMY_ECHELON_DIVISION"
	EchelonArmyEchelonArmyEchelonCorps     EchelonArmyEchelon = "ARMY_ECHELON_CORPS"
	EchelonArmyEchelonArmyEchelonArmy      EchelonArmyEchelon = "ARMY_ECHELON_ARMY"
)

func NewEchelonArmyEchelonFromString(s string) (EchelonArmyEchelon, error) {
	switch s {
	case "ARMY_ECHELON_INVALID":
		return EchelonArmyEchelonArmyEchelonInvalid, nil
	case "ARMY_ECHELON_FIRE_TEAM":
		return EchelonArmyEchelonArmyEchelonFireTeam, nil
	case "ARMY_ECHELON_SQUAD":
		return EchelonArmyEchelonArmyEchelonSquad, nil
	case "ARMY_ECHELON_PLATOON":
		return EchelonArmyEchelonArmyEchelonPlatoon, nil
	case "ARMY_ECHELON_COMPANY":
		return EchelonArmyEchelonArmyEchelonCompany, nil
	case "ARMY_ECHELON_BATTALION":
		return EchelonArmyEchelonArmyEchelonBattalion, nil
	case "ARMY_ECHELON_REGIMENT":
		return EchelonArmyEchelonArmyEchelonRegiment, nil
	case "ARMY_ECHELON_BRIGADE":
		return EchelonArmyEchelonArmyEchelonBrigade, nil
	case "ARMY_ECHELON_DIVISION":
		return EchelonArmyEchelonArmyEchelonDivision, nil
	case "ARMY_ECHELON_CORPS":
		return EchelonArmyEchelonArmyEchelonCorps, nil
	case "ARMY_ECHELON_ARMY":
		return EchelonArmyEchelonArmyEchelonArmy, nil
	}
	var t EchelonArmyEchelon
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EchelonArmyEchelon) Ptr() *EchelonArmyEchelon {
	return &e
}

// A representation of a single emitter notation.
type EmitterNotation struct {
	EmitterNotation *string `json:"emitterNotation,omitempty" url:"emitterNotation,omitempty"`
	// confidence as a percentage that the emitter notation in this component is accurate
	Confidence *float64 `json:"confidence,omitempty" url:"confidence,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmitterNotation) GetEmitterNotation() *string {
	if e == nil {
		return nil
	}
	return e.EmitterNotation
}

func (e *EmitterNotation) GetConfidence() *float64 {
	if e == nil {
		return nil
	}
	return e.Confidence
}

func (e *EmitterNotation) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmitterNotation) UnmarshalJSON(data []byte) error {
	type unmarshaler EmitterNotation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmitterNotation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmitterNotation) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The entity object represents a single known object within the Lattice operational environment. It contains
//
//	all data associated with the entity, such as its name, ID, and other relevant components.
type Entity struct {
	// A Globally Unique Identifier (GUID) for your entity. If this field is empty, the Entity Manager API
	//
	//	automatically generates an ID when it creates the entity.
	EntityID *string `json:"entityId,omitempty" url:"entityId,omitempty"`
	// A human-readable entity description that's helpful for debugging purposes and human
	//
	//	traceability. If this field is empty, the Entity Manager API generates one for you.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Indicates the entity is active and should have a lifecycle state of CREATE or UPDATE.
	//
	//	Set this field to true when publishing an entity.
	IsLive *bool `json:"isLive,omitempty" url:"isLive,omitempty"`
	// The time when the entity was first known to the entity producer. If this field is empty, the Entity Manager API uses the
	//
	//	current timestamp of when the entity is first received.
	//	For example, when a drone is first powered on, it might report its startup time as the created time.
	//	The timestamp doesn't change for the lifetime of an entity.
	CreatedTime *time.Time `json:"createdTime,omitempty" url:"createdTime,omitempty"`
	// Future time that expires an entity and updates the is_live flag.
	//
	//	For entities that are constantly updating, the expiry time also updates.
	//	In some cases, this may differ from is_live.
	//	Example: Entities with tasks exported to an external system must remain
	//	active even after they expire.
	//	This field is required when publishing a prepopulated entity.
	//	The expiry time must be in the future, but less than 30 days from the current time.
	ExpiryTime *time.Time `json:"expiryTime,omitempty" url:"expiryTime,omitempty"`
	// Use noExpiry only when the entity contains information that should be available to other
	//
	//	tasks or integrations beyond its immediate operational context. For example, use noExpiry
	//	for long-living geographical entities that maintain persistent relevance across multiple
	//	operations or tasks.
	NoExpiry *bool `json:"noExpiry,omitempty" url:"noExpiry,omitempty"`
	// Human-readable descriptions of what the entity is currently doing.
	Status *Status `json:"status,omitempty" url:"status,omitempty"`
	// Geospatial data related to the entity, including its position, kinematics, and orientation.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`
	// Indicates uncertainty of the entity's position and kinematics.
	LocationUncertainty *LocationUncertainty `json:"locationUncertainty,omitempty" url:"locationUncertainty,omitempty"`
	// Geospatial representation of the entity, including entities that cover an area rather than a fixed point.
	GeoShape *GeoShape `json:"geoShape,omitempty" url:"geoShape,omitempty"`
	// Additional details on what the geospatial area or point represents, along with visual display details.
	GeoDetails *GeoDetails `json:"geoDetails,omitempty" url:"geoDetails,omitempty"`
	// Entity name displayed in the Lattice UI side panel. Also includes identifiers that other systems can use to reference the same entity.
	Aliases *Aliases `json:"aliases,omitempty" url:"aliases,omitempty"`
	// If this entity is tracked by another entity, this component contains data related to how it's being tracked.
	Tracked *Tracked `json:"tracked,omitempty" url:"tracked,omitempty"`
	// If this entity has been correlated or decorrelated to another one, this component contains information on the correlation or decorrelation.
	Correlation *Correlation `json:"correlation,omitempty" url:"correlation,omitempty"`
	// View of the entity.
	MilView *MilView `json:"milView,omitempty" url:"milView,omitempty"`
	// Ontology defines an entity's categorization in Lattice, and improves data retrieval and integration. Builds a standardized representation of the entity.
	Ontology *Ontology `json:"ontology,omitempty" url:"ontology,omitempty"`
	// Details an entity's available sensors.
	Sensors *Sensors `json:"sensors,omitempty" url:"sensors,omitempty"`
	// Details an entity's available payloads.
	Payloads *Payloads `json:"payloads,omitempty" url:"payloads,omitempty"`
	// Details the entity's power source.
	PowerState *PowerState `json:"powerState,omitempty" url:"powerState,omitempty"`
	// The primary data source provenance for this entity.
	Provenance *Provenance `json:"provenance,omitempty" url:"provenance,omitempty"`
	// Provenance of override data.
	Overrides *Overrides `json:"overrides,omitempty" url:"overrides,omitempty"`
	// Describes an entity's specific characteristics and the operations that can be performed on the entity.
	//
	//	For example, "simulated" informs the operator that the entity is from a simulation, and "deletable"
	//	informs the operator (and system) that the delete operation is valid against the entity.
	Indicators *Indicators `json:"indicators,omitempty" url:"indicators,omitempty"`
	// The prioritization associated with an entity, such as if it's a threat or a high-value target.
	TargetPriority *TargetPriority `json:"targetPriority,omitempty" url:"targetPriority,omitempty"`
	// Describes an entity's signal characteristics, primarily used when an entity is a signal of interest.
	Signal *Signal `json:"signal,omitempty" url:"signal,omitempty"`
	// A message describing any transponder codes associated with Mode 1, 2, 3, 4, 5, S interrogations. These are related to ADS-B modes.
	TransponderCodes *TransponderCodes `json:"transponderCodes,omitempty" url:"transponderCodes,omitempty"`
	// Describes an entity's security classification levels at an overall classification level and on a per
	//
	//	field level.
	DataClassification *Classification `json:"dataClassification,omitempty" url:"dataClassification,omitempty"`
	// A catalog of tasks that can be performed by an entity.
	TaskCatalog *TaskCatalog `json:"taskCatalog,omitempty" url:"taskCatalog,omitempty"`
	// Media associated with an entity, such as videos, images, or thumbnails.
	Media *Media `json:"media,omitempty" url:"media,omitempty"`
	// The relationships between this entity and other entities in the common operational picture (COP).
	Relationships *Relationships `json:"relationships,omitempty" url:"relationships,omitempty"`
	// Visual details associated with the display of an entity in the client.
	VisualDetails *VisualDetails `json:"visualDetails,omitempty" url:"visualDetails,omitempty"`
	// Physical dimensions of the entity.
	Dimensions *Dimensions `json:"dimensions,omitempty" url:"dimensions,omitempty"`
	// Additional information about an entity's route.
	RouteDetails *RouteDetails `json:"routeDetails,omitempty" url:"routeDetails,omitempty"`
	// Schedules associated with this entity.
	Schedules *Schedules `json:"schedules,omitempty" url:"schedules,omitempty"`
	// Health metrics or connection status reported by the entity.
	Health *Health `json:"health,omitempty" url:"health,omitempty"`
	// Details for the group associated with this entity.
	GroupDetails *GroupDetails `json:"groupDetails,omitempty" url:"groupDetails,omitempty"`
	// Contains relevant supply information for the entity, such as fuel.
	Supplies *Supplies `json:"supplies,omitempty" url:"supplies,omitempty"`
	// Orbit information for space objects.
	Orbit *Orbit `json:"orbit,omitempty" url:"orbit,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Entity) GetEntityID() *string {
	if e == nil {
		return nil
	}
	return e.EntityID
}

func (e *Entity) GetDescription() *string {
	if e == nil {
		return nil
	}
	return e.Description
}

func (e *Entity) GetIsLive() *bool {
	if e == nil {
		return nil
	}
	return e.IsLive
}

func (e *Entity) GetCreatedTime() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedTime
}

func (e *Entity) GetExpiryTime() *time.Time {
	if e == nil {
		return nil
	}
	return e.ExpiryTime
}

func (e *Entity) GetNoExpiry() *bool {
	if e == nil {
		return nil
	}
	return e.NoExpiry
}

func (e *Entity) GetStatus() *Status {
	if e == nil {
		return nil
	}
	return e.Status
}

func (e *Entity) GetLocation() *Location {
	if e == nil {
		return nil
	}
	return e.Location
}

func (e *Entity) GetLocationUncertainty() *LocationUncertainty {
	if e == nil {
		return nil
	}
	return e.LocationUncertainty
}

func (e *Entity) GetGeoShape() *GeoShape {
	if e == nil {
		return nil
	}
	return e.GeoShape
}

func (e *Entity) GetGeoDetails() *GeoDetails {
	if e == nil {
		return nil
	}
	return e.GeoDetails
}

func (e *Entity) GetAliases() *Aliases {
	if e == nil {
		return nil
	}
	return e.Aliases
}

func (e *Entity) GetTracked() *Tracked {
	if e == nil {
		return nil
	}
	return e.Tracked
}

func (e *Entity) GetCorrelation() *Correlation {
	if e == nil {
		return nil
	}
	return e.Correlation
}

func (e *Entity) GetMilView() *MilView {
	if e == nil {
		return nil
	}
	return e.MilView
}

func (e *Entity) GetOntology() *Ontology {
	if e == nil {
		return nil
	}
	return e.Ontology
}

func (e *Entity) GetSensors() *Sensors {
	if e == nil {
		return nil
	}
	return e.Sensors
}

func (e *Entity) GetPayloads() *Payloads {
	if e == nil {
		return nil
	}
	return e.Payloads
}

func (e *Entity) GetPowerState() *PowerState {
	if e == nil {
		return nil
	}
	return e.PowerState
}

func (e *Entity) GetProvenance() *Provenance {
	if e == nil {
		return nil
	}
	return e.Provenance
}

func (e *Entity) GetOverrides() *Overrides {
	if e == nil {
		return nil
	}
	return e.Overrides
}

func (e *Entity) GetIndicators() *Indicators {
	if e == nil {
		return nil
	}
	return e.Indicators
}

func (e *Entity) GetTargetPriority() *TargetPriority {
	if e == nil {
		return nil
	}
	return e.TargetPriority
}

func (e *Entity) GetSignal() *Signal {
	if e == nil {
		return nil
	}
	return e.Signal
}

func (e *Entity) GetTransponderCodes() *TransponderCodes {
	if e == nil {
		return nil
	}
	return e.TransponderCodes
}

func (e *Entity) GetDataClassification() *Classification {
	if e == nil {
		return nil
	}
	return e.DataClassification
}

func (e *Entity) GetTaskCatalog() *TaskCatalog {
	if e == nil {
		return nil
	}
	return e.TaskCatalog
}

func (e *Entity) GetMedia() *Media {
	if e == nil {
		return nil
	}
	return e.Media
}

func (e *Entity) GetRelationships() *Relationships {
	if e == nil {
		return nil
	}
	return e.Relationships
}

func (e *Entity) GetVisualDetails() *VisualDetails {
	if e == nil {
		return nil
	}
	return e.VisualDetails
}

func (e *Entity) GetDimensions() *Dimensions {
	if e == nil {
		return nil
	}
	return e.Dimensions
}

func (e *Entity) GetRouteDetails() *RouteDetails {
	if e == nil {
		return nil
	}
	return e.RouteDetails
}

func (e *Entity) GetSchedules() *Schedules {
	if e == nil {
		return nil
	}
	return e.Schedules
}

func (e *Entity) GetHealth() *Health {
	if e == nil {
		return nil
	}
	return e.Health
}

func (e *Entity) GetGroupDetails() *GroupDetails {
	if e == nil {
		return nil
	}
	return e.GroupDetails
}

func (e *Entity) GetSupplies() *Supplies {
	if e == nil {
		return nil
	}
	return e.Supplies
}

func (e *Entity) GetOrbit() *Orbit {
	if e == nil {
		return nil
	}
	return e.Orbit
}

func (e *Entity) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Entity) UnmarshalJSON(data []byte) error {
	type embed Entity
	var unmarshaler = struct {
		embed
		CreatedTime *internal.DateTime `json:"createdTime,omitempty"`
		ExpiryTime  *internal.DateTime `json:"expiryTime,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Entity(unmarshaler.embed)
	e.CreatedTime = unmarshaler.CreatedTime.TimePtr()
	e.ExpiryTime = unmarshaler.ExpiryTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Entity) MarshalJSON() ([]byte, error) {
	type embed Entity
	var marshaler = struct {
		embed
		CreatedTime *internal.DateTime `json:"createdTime,omitempty"`
		ExpiryTime  *internal.DateTime `json:"expiryTime,omitempty"`
	}{
		embed:       embed(*e),
		CreatedTime: internal.NewOptionalDateTime(e.CreatedTime),
		ExpiryTime:  internal.NewOptionalDateTime(e.ExpiryTime),
	}
	return json.Marshal(marshaler)
}

func (e *Entity) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Enu struct {
	E *float64 `json:"e,omitempty" url:"e,omitempty"`
	N *float64 `json:"n,omitempty" url:"n,omitempty"`
	U *float64 `json:"u,omitempty" url:"u,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Enu) GetE() *float64 {
	if e == nil {
		return nil
	}
	return e.E
}

func (e *Enu) GetN() *float64 {
	if e == nil {
		return nil
	}
	return e.N
}

func (e *Enu) GetU() *float64 {
	if e == nil {
		return nil
	}
	return e.U
}

func (e *Enu) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Enu) UnmarshalJSON(data []byte) error {
	type unmarshaler Enu
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Enu(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Enu) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Indicates ellipse characteristics and probability that an entity lies within the defined ellipse.
type ErrorEllipse struct {
	// Defines the probability in percentage that an entity lies within the given ellipse: 0-1.
	Probability *float64 `json:"probability,omitempty" url:"probability,omitempty"`
	// Defines the distance from the center point of the ellipse to the furthest distance on the perimeter in meters.
	SemiMajorAxisM *float64 `json:"semiMajorAxisM,omitempty" url:"semiMajorAxisM,omitempty"`
	// Defines the distance from the center point of the ellipse to the shortest distance on the perimeter in meters.
	SemiMinorAxisM *float64 `json:"semiMinorAxisM,omitempty" url:"semiMinorAxisM,omitempty"`
	// The orientation of the semi-major relative to true north in degrees from clockwise: 0-180 due to symmetry across the semi-minor axis.
	OrientationD *float64 `json:"orientationD,omitempty" url:"orientationD,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ErrorEllipse) GetProbability() *float64 {
	if e == nil {
		return nil
	}
	return e.Probability
}

func (e *ErrorEllipse) GetSemiMajorAxisM() *float64 {
	if e == nil {
		return nil
	}
	return e.SemiMajorAxisM
}

func (e *ErrorEllipse) GetSemiMinorAxisM() *float64 {
	if e == nil {
		return nil
	}
	return e.SemiMinorAxisM
}

func (e *ErrorEllipse) GetOrientationD() *float64 {
	if e == nil {
		return nil
	}
	return e.OrientationD
}

func (e *ErrorEllipse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorEllipse) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorEllipse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorEllipse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorEllipse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// A field specific classification information definition.
type FieldClassificationInformation struct {
	// Proto field path which is the string representation of a field.
	//
	//	> example: signal.bandwidth_hz would be bandwidth_hz in the signal component
	FieldPath *string `json:"fieldPath,omitempty" url:"fieldPath,omitempty"`
	// The information which makes up the field level classification marking.
	ClassificationInformation *ClassificationInformation `json:"classificationInformation,omitempty" url:"classificationInformation,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FieldClassificationInformation) GetFieldPath() *string {
	if f == nil {
		return nil
	}
	return f.FieldPath
}

func (f *FieldClassificationInformation) GetClassificationInformation() *ClassificationInformation {
	if f == nil {
		return nil
	}
	return f.ClassificationInformation
}

func (f *FieldClassificationInformation) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldClassificationInformation) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldClassificationInformation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldClassificationInformation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldClassificationInformation) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Sensor Field Of View closely resembling fov.proto SensorFieldOfView.
type FieldOfView struct {
	// The Id for one instance of a FieldOfView, persisted across multiple updates to provide continuity during
	//
	//	smoothing. This is relevant for sensors where the dwell schedule is on the order of
	//	milliseconds, making multiple FOVs a requirement for proper display of search beams.
	FovID *int `json:"fovId,omitempty" url:"fovId,omitempty"`
	// The Id of the mount the sensor is on.
	MountID *string `json:"mountId,omitempty" url:"mountId,omitempty"`
	// The field of view the sensor projected onto the ground.
	ProjectedFrustum *ProjectedFrustum `json:"projectedFrustum,omitempty" url:"projectedFrustum,omitempty"`
	// Center ray of the frustum projected onto the ground.
	ProjectedCenterRay *Position `json:"projectedCenterRay,omitempty" url:"projectedCenterRay,omitempty"`
	// The origin and direction of the center ray for this sensor relative to the ENU frame. A ray which is aligned with
	//
	//	the positive X axis in the sensor frame will be transformed into the ray along the sensor direction in the ENU
	//	frame when transformed by the quaternion contained in this pose.
	CenterRayPose *Pose `json:"centerRayPose,omitempty" url:"centerRayPose,omitempty"`
	// Horizontal field of view in radians.
	HorizontalFov *float64 `json:"horizontalFov,omitempty" url:"horizontalFov,omitempty"`
	// Vertical field of view in radians.
	VerticalFov *float64 `json:"verticalFov,omitempty" url:"verticalFov,omitempty"`
	// Sensor range in meters.
	Range *float64 `json:"range,omitempty" url:"range,omitempty"`
	// The mode that this sensor is currently in, used to display for context in the UI. Some sensors can emit multiple
	//
	//	sensor field of views with different modes, for example a radar can simultaneously search broadly and perform
	//	tighter bounded tracking.
	Mode *FieldOfViewMode `json:"mode,omitempty" url:"mode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FieldOfView) GetFovID() *int {
	if f == nil {
		return nil
	}
	return f.FovID
}

func (f *FieldOfView) GetMountID() *string {
	if f == nil {
		return nil
	}
	return f.MountID
}

func (f *FieldOfView) GetProjectedFrustum() *ProjectedFrustum {
	if f == nil {
		return nil
	}
	return f.ProjectedFrustum
}

func (f *FieldOfView) GetProjectedCenterRay() *Position {
	if f == nil {
		return nil
	}
	return f.ProjectedCenterRay
}

func (f *FieldOfView) GetCenterRayPose() *Pose {
	if f == nil {
		return nil
	}
	return f.CenterRayPose
}

func (f *FieldOfView) GetHorizontalFov() *float64 {
	if f == nil {
		return nil
	}
	return f.HorizontalFov
}

func (f *FieldOfView) GetVerticalFov() *float64 {
	if f == nil {
		return nil
	}
	return f.VerticalFov
}

func (f *FieldOfView) GetRange() *float64 {
	if f == nil {
		return nil
	}
	return f.Range
}

func (f *FieldOfView) GetMode() *FieldOfViewMode {
	if f == nil {
		return nil
	}
	return f.Mode
}

func (f *FieldOfView) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FieldOfView) UnmarshalJSON(data []byte) error {
	type unmarshaler FieldOfView
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FieldOfView(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FieldOfView) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The mode that this sensor is currently in, used to display for context in the UI. Some sensors can emit multiple
//
//	sensor field of views with different modes, for example a radar can simultaneously search broadly and perform
//	tighter bounded tracking.
type FieldOfViewMode string

const (
	FieldOfViewModeSensorModeInvalid       FieldOfViewMode = "SENSOR_MODE_INVALID"
	FieldOfViewModeSensorModeSearch        FieldOfViewMode = "SENSOR_MODE_SEARCH"
	FieldOfViewModeSensorModeTrack         FieldOfViewMode = "SENSOR_MODE_TRACK"
	FieldOfViewModeSensorModeWeaponSupport FieldOfViewMode = "SENSOR_MODE_WEAPON_SUPPORT"
	FieldOfViewModeSensorModeAuto          FieldOfViewMode = "SENSOR_MODE_AUTO"
	FieldOfViewModeSensorModeMute          FieldOfViewMode = "SENSOR_MODE_MUTE"
)

func NewFieldOfViewModeFromString(s string) (FieldOfViewMode, error) {
	switch s {
	case "SENSOR_MODE_INVALID":
		return FieldOfViewModeSensorModeInvalid, nil
	case "SENSOR_MODE_SEARCH":
		return FieldOfViewModeSensorModeSearch, nil
	case "SENSOR_MODE_TRACK":
		return FieldOfViewModeSensorModeTrack, nil
	case "SENSOR_MODE_WEAPON_SUPPORT":
		return FieldOfViewModeSensorModeWeaponSupport, nil
	case "SENSOR_MODE_AUTO":
		return FieldOfViewModeSensorModeAuto, nil
	case "SENSOR_MODE_MUTE":
		return FieldOfViewModeSensorModeMute, nil
	}
	var t FieldOfViewMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FieldOfViewMode) Ptr() *FieldOfViewMode {
	return &f
}

// A fix of a signal. No extra fields but it is expected that location should be populated when using this report.
type Fixed struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Fixed) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Fixed) UnmarshalJSON(data []byte) error {
	type unmarshaler Fixed
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Fixed(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Fixed) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// A component for describing frequency.
type Frequency struct {
	// Indicates a frequency of a signal (Hz) with its standard deviation.
	FrequencyHz *Measurement `json:"frequencyHz,omitempty" url:"frequencyHz,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Frequency) GetFrequencyHz() *Measurement {
	if f == nil {
		return nil
	}
	return f.FrequencyHz
}

func (f *Frequency) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Frequency) UnmarshalJSON(data []byte) error {
	type unmarshaler Frequency
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Frequency(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Frequency) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// A component to represent a frequency range.
type FrequencyRange struct {
	// Indicates the lowest measured frequency of a signal (Hz).
	MinimumFrequencyHz *Frequency `json:"minimumFrequencyHz,omitempty" url:"minimumFrequencyHz,omitempty"`
	// Indicates the maximum measured frequency of a signal (Hz).
	MaximumFrequencyHz *Frequency `json:"maximumFrequencyHz,omitempty" url:"maximumFrequencyHz,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FrequencyRange) GetMinimumFrequencyHz() *Frequency {
	if f == nil {
		return nil
	}
	return f.MinimumFrequencyHz
}

func (f *FrequencyRange) GetMaximumFrequencyHz() *Frequency {
	if f == nil {
		return nil
	}
	return f.MaximumFrequencyHz
}

func (f *FrequencyRange) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FrequencyRange) UnmarshalJSON(data []byte) error {
	type unmarshaler FrequencyRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FrequencyRange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FrequencyRange) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Fuel describes an entity's repository of fuels stores including current amount, operational requirements, and maximum authorized capacity
type Fuel struct {
	// unique fuel identifier
	FuelID *string `json:"fuelId,omitempty" url:"fuelId,omitempty"`
	// long form name of the fuel source.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// timestamp the information was reported
	ReportedDate *time.Time `json:"reportedDate,omitempty" url:"reportedDate,omitempty"`
	// amount of gallons on hand
	AmountGallons *int `json:"amountGallons,omitempty" url:"amountGallons,omitempty"`
	// how much the asset is allowed to have available (in gallons)
	MaxAuthorizedCapacityGallons *int `json:"maxAuthorizedCapacityGallons,omitempty" url:"maxAuthorizedCapacityGallons,omitempty"`
	// minimum required for operations (in gallons)
	OperationalRequirementGallons *int `json:"operationalRequirementGallons,omitempty" url:"operationalRequirementGallons,omitempty"`
	// fuel in a single asset may have different levels of classification
	//
	//	use case: fuel for a SECRET asset while diesel fuel may be UNCLASSIFIED
	DataClassification *Classification `json:"dataClassification,omitempty" url:"dataClassification,omitempty"`
	// source of information
	DataSource *string `json:"dataSource,omitempty" url:"dataSource,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Fuel) GetFuelID() *string {
	if f == nil {
		return nil
	}
	return f.FuelID
}

func (f *Fuel) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *Fuel) GetReportedDate() *time.Time {
	if f == nil {
		return nil
	}
	return f.ReportedDate
}

func (f *Fuel) GetAmountGallons() *int {
	if f == nil {
		return nil
	}
	return f.AmountGallons
}

func (f *Fuel) GetMaxAuthorizedCapacityGallons() *int {
	if f == nil {
		return nil
	}
	return f.MaxAuthorizedCapacityGallons
}

func (f *Fuel) GetOperationalRequirementGallons() *int {
	if f == nil {
		return nil
	}
	return f.OperationalRequirementGallons
}

func (f *Fuel) GetDataClassification() *Classification {
	if f == nil {
		return nil
	}
	return f.DataClassification
}

func (f *Fuel) GetDataSource() *string {
	if f == nil {
		return nil
	}
	return f.DataSource
}

func (f *Fuel) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Fuel) UnmarshalJSON(data []byte) error {
	type embed Fuel
	var unmarshaler = struct {
		embed
		ReportedDate *internal.DateTime `json:"reportedDate,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = Fuel(unmarshaler.embed)
	f.ReportedDate = unmarshaler.ReportedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Fuel) MarshalJSON() ([]byte, error) {
	type embed Fuel
	var marshaler = struct {
		embed
		ReportedDate *internal.DateTime `json:"reportedDate,omitempty"`
	}{
		embed:        embed(*f),
		ReportedDate: internal.NewOptionalDateTime(f.ReportedDate),
	}
	return json.Marshal(marshaler)
}

func (f *Fuel) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// A component that describes a geo-entity.
type GeoDetails struct {
	Type        *GeoDetailsType     `json:"type,omitempty" url:"type,omitempty"`
	ControlArea *ControlAreaDetails `json:"controlArea,omitempty" url:"controlArea,omitempty"`
	Acm         *AcmDetails         `json:"acm,omitempty" url:"acm,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeoDetails) GetType() *GeoDetailsType {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GeoDetails) GetControlArea() *ControlAreaDetails {
	if g == nil {
		return nil
	}
	return g.ControlArea
}

func (g *GeoDetails) GetAcm() *AcmDetails {
	if g == nil {
		return nil
	}
	return g.Acm
}

func (g *GeoDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeoDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler GeoDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeoDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeoDetails) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeoDetailsType string

const (
	GeoDetailsTypeGeoTypeInvalid        GeoDetailsType = "GEO_TYPE_INVALID"
	GeoDetailsTypeGeoTypeGeneral        GeoDetailsType = "GEO_TYPE_GENERAL"
	GeoDetailsTypeGeoTypeHazard         GeoDetailsType = "GEO_TYPE_HAZARD"
	GeoDetailsTypeGeoTypeEmergency      GeoDetailsType = "GEO_TYPE_EMERGENCY"
	GeoDetailsTypeGeoTypeEngagementZone GeoDetailsType = "GEO_TYPE_ENGAGEMENT_ZONE"
	GeoDetailsTypeGeoTypeControlArea    GeoDetailsType = "GEO_TYPE_CONTROL_AREA"
	GeoDetailsTypeGeoTypeBullseye       GeoDetailsType = "GEO_TYPE_BULLSEYE"
	GeoDetailsTypeGeoTypeAcm            GeoDetailsType = "GEO_TYPE_ACM"
)

func NewGeoDetailsTypeFromString(s string) (GeoDetailsType, error) {
	switch s {
	case "GEO_TYPE_INVALID":
		return GeoDetailsTypeGeoTypeInvalid, nil
	case "GEO_TYPE_GENERAL":
		return GeoDetailsTypeGeoTypeGeneral, nil
	case "GEO_TYPE_HAZARD":
		return GeoDetailsTypeGeoTypeHazard, nil
	case "GEO_TYPE_EMERGENCY":
		return GeoDetailsTypeGeoTypeEmergency, nil
	case "GEO_TYPE_ENGAGEMENT_ZONE":
		return GeoDetailsTypeGeoTypeEngagementZone, nil
	case "GEO_TYPE_CONTROL_AREA":
		return GeoDetailsTypeGeoTypeControlArea, nil
	case "GEO_TYPE_BULLSEYE":
		return GeoDetailsTypeGeoTypeBullseye, nil
	case "GEO_TYPE_ACM":
		return GeoDetailsTypeGeoTypeAcm, nil
	}
	var t GeoDetailsType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GeoDetailsType) Ptr() *GeoDetailsType {
	return &g
}

// An ellipse shaped geo-entity.
//
//	For a circle, the major and minor axis would be the same values.
//	This shape is NOT Geo-JSON compatible.
type GeoEllipse struct {
	// Defines the distance from the center point of the ellipse to the furthest distance on the perimeter in meters.
	SemiMajorAxisM *float64 `json:"semiMajorAxisM,omitempty" url:"semiMajorAxisM,omitempty"`
	// Defines the distance from the center point of the ellipse to the shortest distance on the perimeter in meters.
	SemiMinorAxisM *float64 `json:"semiMinorAxisM,omitempty" url:"semiMinorAxisM,omitempty"`
	// The orientation of the semi-major relative to true north in degrees from clockwise: 0-180 due to symmetry across the semi-minor axis.
	OrientationD *float64 `json:"orientationD,omitempty" url:"orientationD,omitempty"`
	// Optional height above entity position to extrude in meters. A non-zero value creates an elliptic cylinder
	HeightM *float64 `json:"heightM,omitempty" url:"heightM,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeoEllipse) GetSemiMajorAxisM() *float64 {
	if g == nil {
		return nil
	}
	return g.SemiMajorAxisM
}

func (g *GeoEllipse) GetSemiMinorAxisM() *float64 {
	if g == nil {
		return nil
	}
	return g.SemiMinorAxisM
}

func (g *GeoEllipse) GetOrientationD() *float64 {
	if g == nil {
		return nil
	}
	return g.OrientationD
}

func (g *GeoEllipse) GetHeightM() *float64 {
	if g == nil {
		return nil
	}
	return g.HeightM
}

func (g *GeoEllipse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeoEllipse) UnmarshalJSON(data []byte) error {
	type unmarshaler GeoEllipse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeoEllipse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeoEllipse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An ellipsoid shaped geo-entity.
//
//	Principal axis lengths are defined in entity body space
//	This shape is NOT Geo-JSON compatible.
type GeoEllipsoid struct {
	// Defines the distance from the center point to the surface along the forward axis
	ForwardAxisM *float64 `json:"forwardAxisM,omitempty" url:"forwardAxisM,omitempty"`
	// Defines the distance from the center point to the surface along the side axis
	SideAxisM *float64 `json:"sideAxisM,omitempty" url:"sideAxisM,omitempty"`
	// Defines the distance from the center point to the surface along the up axis
	UpAxisM *float64 `json:"upAxisM,omitempty" url:"upAxisM,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeoEllipsoid) GetForwardAxisM() *float64 {
	if g == nil {
		return nil
	}
	return g.ForwardAxisM
}

func (g *GeoEllipsoid) GetSideAxisM() *float64 {
	if g == nil {
		return nil
	}
	return g.SideAxisM
}

func (g *GeoEllipsoid) GetUpAxisM() *float64 {
	if g == nil {
		return nil
	}
	return g.UpAxisM
}

func (g *GeoEllipsoid) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeoEllipsoid) UnmarshalJSON(data []byte) error {
	type unmarshaler GeoEllipsoid
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeoEllipsoid(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeoEllipsoid) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A line shaped geo-entity.
//
//	See https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.4
type GeoLine struct {
	Positions []*Position `json:"positions,omitempty" url:"positions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeoLine) GetPositions() []*Position {
	if g == nil {
		return nil
	}
	return g.Positions
}

func (g *GeoLine) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeoLine) UnmarshalJSON(data []byte) error {
	type unmarshaler GeoLine
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeoLine(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeoLine) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A point shaped geo-entity.
//
//	See https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.2
type GeoPoint struct {
	Position *Position `json:"position,omitempty" url:"position,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeoPoint) GetPosition() *Position {
	if g == nil {
		return nil
	}
	return g.Position
}

func (g *GeoPoint) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeoPoint) UnmarshalJSON(data []byte) error {
	type unmarshaler GeoPoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeoPoint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeoPoint) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A polygon shaped geo-entity.
//
//	See https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.6, only canonical representations accepted
type GeoPolygon struct {
	// An array of LinearRings where the first item is the exterior ring and subsequent items are interior rings.
	Rings []*LinearRing `json:"rings,omitempty" url:"rings,omitempty"`
	// An extension hint that this polygon is a rectangle. When true this implies several things:
	//   - exactly 1 linear ring with 5 points (starting corner, 3 other corners and start again)
	//   - each point has the same altitude corresponding with the plane of the rectangle
	//   - each point has the same height (either all present and equal, or all not present)
	IsRectangle *bool `json:"isRectangle,omitempty" url:"isRectangle,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeoPolygon) GetRings() []*LinearRing {
	if g == nil {
		return nil
	}
	return g.Rings
}

func (g *GeoPolygon) GetIsRectangle() *bool {
	if g == nil {
		return nil
	}
	return g.IsRectangle
}

func (g *GeoPolygon) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeoPolygon) UnmarshalJSON(data []byte) error {
	type unmarshaler GeoPolygon
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeoPolygon(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeoPolygon) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A position in a GeoPolygon with an optional extruded height.
type GeoPolygonPosition struct {
	// base position. if no altitude set, its on the ground.
	Position *Position `json:"position,omitempty" url:"position,omitempty"`
	// optional height above base position to extrude in meters.
	//
	//	for a given polygon, all points should have a height or none of them.
	//	strictly GeoJSON compatible polygons will not have this set.
	HeightM *float64 `json:"heightM,omitempty" url:"heightM,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeoPolygonPosition) GetPosition() *Position {
	if g == nil {
		return nil
	}
	return g.Position
}

func (g *GeoPolygonPosition) GetHeightM() *float64 {
	if g == nil {
		return nil
	}
	return g.HeightM
}

func (g *GeoPolygonPosition) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeoPolygonPosition) UnmarshalJSON(data []byte) error {
	type unmarshaler GeoPolygonPosition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeoPolygonPosition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeoPolygonPosition) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A component that describes the shape of a geo-entity.
type GeoShape struct {
	Point     *GeoPoint     `json:"point,omitempty" url:"point,omitempty"`
	Line      *GeoLine      `json:"line,omitempty" url:"line,omitempty"`
	Polygon   *GeoPolygon   `json:"polygon,omitempty" url:"polygon,omitempty"`
	Ellipse   *GeoEllipse   `json:"ellipse,omitempty" url:"ellipse,omitempty"`
	Ellipsoid *GeoEllipsoid `json:"ellipsoid,omitempty" url:"ellipsoid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeoShape) GetPoint() *GeoPoint {
	if g == nil {
		return nil
	}
	return g.Point
}

func (g *GeoShape) GetLine() *GeoLine {
	if g == nil {
		return nil
	}
	return g.Line
}

func (g *GeoShape) GetPolygon() *GeoPolygon {
	if g == nil {
		return nil
	}
	return g.Polygon
}

func (g *GeoShape) GetEllipse() *GeoEllipse {
	if g == nil {
		return nil
	}
	return g.Ellipse
}

func (g *GeoShape) GetEllipsoid() *GeoEllipsoid {
	if g == nil {
		return nil
	}
	return g.Ellipsoid
}

func (g *GeoShape) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeoShape) UnmarshalJSON(data []byte) error {
	type unmarshaler GeoShape
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeoShape(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeoShape) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.
type GoogleProtobufAny struct {
	// The type of the serialized message.
	Type *string `json:"@type,omitempty" url:"@type,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (g *GoogleProtobufAny) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GoogleProtobufAny) GetExtraProperties() map[string]interface{} {
	return g.ExtraProperties
}

func (g *GoogleProtobufAny) UnmarshalJSON(data []byte) error {
	type embed GoogleProtobufAny
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GoogleProtobufAny(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.ExtraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleProtobufAny) MarshalJSON() ([]byte, error) {
	type embed GoogleProtobufAny
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, g.ExtraProperties)
}

func (g *GoogleProtobufAny) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A GroupChild relationship is a uni-directional relationship indicating that (1) this entity
//
//	represents an Entity Group and (2) the related entity is a child member of this group. The presence of this
//	relationship alone determines that the type of group is an Entity Group.
type GroupChild struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupChild) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupChild) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupChild
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupChild(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupChild) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Details related to grouping for this entity
type GroupDetails struct {
	Team    *Team    `json:"team,omitempty" url:"team,omitempty"`
	Echelon *Echelon `json:"echelon,omitempty" url:"echelon,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupDetails) GetTeam() *Team {
	if g == nil {
		return nil
	}
	return g.Team
}

func (g *GroupDetails) GetEchelon() *Echelon {
	if g == nil {
		return nil
	}
	return g.Echelon
}

func (g *GroupDetails) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupDetails) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A GroupParent relationship is a uni-directional relationship indicating that this entity is a member of
//
//	the Entity Group represented by the related entity. The presence of this relationship alone determines that
//	the type of group that this entity is a member of is an Entity Group.
type GroupParent struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupParent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupParent) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupParent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupParent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupParent) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// General health of the entity as reported by the entity.
type Health struct {
	// Status indicating whether the entity is able to communicate with Entity Manager.
	ConnectionStatus *HealthConnectionStatus `json:"connectionStatus,omitempty" url:"connectionStatus,omitempty"`
	// Top-level health status; typically a roll-up of individual component healths.
	HealthStatus *HealthHealthStatus `json:"healthStatus,omitempty" url:"healthStatus,omitempty"`
	// Health of individual components running on this Entity.
	Components []*ComponentHealth `json:"components,omitempty" url:"components,omitempty"`
	// The update time for the top-level health information.
	//
	//	If this timestamp is unset, the data is assumed to be most recent
	UpdateTime *time.Time `json:"updateTime,omitempty" url:"updateTime,omitempty"`
	// Active alerts indicate a critical change in system state sent by the asset
	//
	//	that must be made known to an operator or consumer of the common operating picture.
	//	Alerts are different from ComponentHealth messages--an active alert does not necessarily
	//	indicate a component is in an unhealthy state. For example, an asset may trigger
	//	an active alert based on fuel levels running low. Alerts should be removed from this list when their conditions
	//	are cleared. In other words, only active alerts should be reported here.
	ActiveAlerts []*Alert `json:"activeAlerts,omitempty" url:"activeAlerts,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *Health) GetConnectionStatus() *HealthConnectionStatus {
	if h == nil {
		return nil
	}
	return h.ConnectionStatus
}

func (h *Health) GetHealthStatus() *HealthHealthStatus {
	if h == nil {
		return nil
	}
	return h.HealthStatus
}

func (h *Health) GetComponents() []*ComponentHealth {
	if h == nil {
		return nil
	}
	return h.Components
}

func (h *Health) GetUpdateTime() *time.Time {
	if h == nil {
		return nil
	}
	return h.UpdateTime
}

func (h *Health) GetActiveAlerts() []*Alert {
	if h == nil {
		return nil
	}
	return h.ActiveAlerts
}

func (h *Health) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *Health) UnmarshalJSON(data []byte) error {
	type embed Health
	var unmarshaler = struct {
		embed
		UpdateTime *internal.DateTime `json:"updateTime,omitempty"`
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = Health(unmarshaler.embed)
	h.UpdateTime = unmarshaler.UpdateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *Health) MarshalJSON() ([]byte, error) {
	type embed Health
	var marshaler = struct {
		embed
		UpdateTime *internal.DateTime `json:"updateTime,omitempty"`
	}{
		embed:      embed(*h),
		UpdateTime: internal.NewOptionalDateTime(h.UpdateTime),
	}
	return json.Marshal(marshaler)
}

func (h *Health) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// Status indicating whether the entity is able to communicate with Entity Manager.
type HealthConnectionStatus string

const (
	HealthConnectionStatusConnectionStatusInvalid HealthConnectionStatus = "CONNECTION_STATUS_INVALID"
	HealthConnectionStatusConnectionStatusOnline  HealthConnectionStatus = "CONNECTION_STATUS_ONLINE"
	HealthConnectionStatusConnectionStatusOffline HealthConnectionStatus = "CONNECTION_STATUS_OFFLINE"
)

func NewHealthConnectionStatusFromString(s string) (HealthConnectionStatus, error) {
	switch s {
	case "CONNECTION_STATUS_INVALID":
		return HealthConnectionStatusConnectionStatusInvalid, nil
	case "CONNECTION_STATUS_ONLINE":
		return HealthConnectionStatusConnectionStatusOnline, nil
	case "CONNECTION_STATUS_OFFLINE":
		return HealthConnectionStatusConnectionStatusOffline, nil
	}
	var t HealthConnectionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HealthConnectionStatus) Ptr() *HealthConnectionStatus {
	return &h
}

// Top-level health status; typically a roll-up of individual component healths.
type HealthHealthStatus string

const (
	HealthHealthStatusHealthStatusInvalid  HealthHealthStatus = "HEALTH_STATUS_INVALID"
	HealthHealthStatusHealthStatusHealthy  HealthHealthStatus = "HEALTH_STATUS_HEALTHY"
	HealthHealthStatusHealthStatusWarn     HealthHealthStatus = "HEALTH_STATUS_WARN"
	HealthHealthStatusHealthStatusFail     HealthHealthStatus = "HEALTH_STATUS_FAIL"
	HealthHealthStatusHealthStatusOffline  HealthHealthStatus = "HEALTH_STATUS_OFFLINE"
	HealthHealthStatusHealthStatusNotReady HealthHealthStatus = "HEALTH_STATUS_NOT_READY"
)

func NewHealthHealthStatusFromString(s string) (HealthHealthStatus, error) {
	switch s {
	case "HEALTH_STATUS_INVALID":
		return HealthHealthStatusHealthStatusInvalid, nil
	case "HEALTH_STATUS_HEALTHY":
		return HealthHealthStatusHealthStatusHealthy, nil
	case "HEALTH_STATUS_WARN":
		return HealthHealthStatusHealthStatusWarn, nil
	case "HEALTH_STATUS_FAIL":
		return HealthHealthStatusHealthStatusFail, nil
	case "HEALTH_STATUS_OFFLINE":
		return HealthHealthStatusHealthStatusOffline, nil
	case "HEALTH_STATUS_NOT_READY":
		return HealthHealthStatusHealthStatusNotReady, nil
	}
	var t HealthHealthStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HealthHealthStatus) Ptr() *HealthHealthStatus {
	return &h
}

// Describes whether something is a high value target or not.
type HighValueTarget struct {
	// Indicates whether the target matches any description from a high value target list.
	IsHighValueTarget *bool `json:"isHighValueTarget,omitempty" url:"isHighValueTarget,omitempty"`
	// The priority associated with the target. If the target's description appears on multiple high value target lists,
	//
	//	the priority will be a reflection of the highest priority of all of those list's target description.
	//
	//	A lower value indicates the target is of a higher priority, with 1 being the highest possible priority. A value of
	//	0 indicates there is no priority associated with this target.
	TargetPriority *int `json:"targetPriority,omitempty" url:"targetPriority,omitempty"`
	// All of the high value target descriptions that the target matches against.
	TargetMatches []*HighValueTargetMatch `json:"targetMatches,omitempty" url:"targetMatches,omitempty"`
	// Indicates whether the target is a 'High Payoff Target'. Targets can be one or both of high value and high payoff.
	IsHighPayoffTarget *bool `json:"isHighPayoffTarget,omitempty" url:"isHighPayoffTarget,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HighValueTarget) GetIsHighValueTarget() *bool {
	if h == nil {
		return nil
	}
	return h.IsHighValueTarget
}

func (h *HighValueTarget) GetTargetPriority() *int {
	if h == nil {
		return nil
	}
	return h.TargetPriority
}

func (h *HighValueTarget) GetTargetMatches() []*HighValueTargetMatch {
	if h == nil {
		return nil
	}
	return h.TargetMatches
}

func (h *HighValueTarget) GetIsHighPayoffTarget() *bool {
	if h == nil {
		return nil
	}
	return h.IsHighPayoffTarget
}

func (h *HighValueTarget) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HighValueTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler HighValueTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HighValueTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HighValueTarget) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HighValueTargetMatch struct {
	// The ID of the high value target list that matches the target description.
	HighValueTargetListID *string `json:"highValueTargetListId,omitempty" url:"highValueTargetListId,omitempty"`
	// The ID of the specific high value target description within a high value target list that was matched against.
	//
	//	The ID is considered to be a globally unique identifier across all high value target IDs.
	HighValueTargetDescriptionID *string `json:"highValueTargetDescriptionId,omitempty" url:"highValueTargetDescriptionId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HighValueTargetMatch) GetHighValueTargetListID() *string {
	if h == nil {
		return nil
	}
	return h.HighValueTargetListID
}

func (h *HighValueTargetMatch) GetHighValueTargetDescriptionID() *string {
	if h == nil {
		return nil
	}
	return h.HighValueTargetDescriptionID
}

func (h *HighValueTargetMatch) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HighValueTargetMatch) UnmarshalJSON(data []byte) error {
	type unmarshaler HighValueTargetMatch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HighValueTargetMatch(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HighValueTargetMatch) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// Indicators to describe entity to consumers.
type Indicators struct {
	Simulated *bool `json:"simulated,omitempty" url:"simulated,omitempty"`
	Exercise  *bool `json:"exercise,omitempty" url:"exercise,omitempty"`
	Emergency *bool `json:"emergency,omitempty" url:"emergency,omitempty"`
	C2        *bool `json:"c2,omitempty" url:"c2,omitempty"`
	// Indicates the Entity should be egressed to external sources.
	//
	//	Integrations choose how the egressing happens (e.g. if an Entity needs fuzzing).
	Egressable *bool `json:"egressable,omitempty" url:"egressable,omitempty"`
	// A signal of arbitrary importance such that the entity should be globally marked for all users
	Starred *bool `json:"starred,omitempty" url:"starred,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Indicators) GetSimulated() *bool {
	if i == nil {
		return nil
	}
	return i.Simulated
}

func (i *Indicators) GetExercise() *bool {
	if i == nil {
		return nil
	}
	return i.Exercise
}

func (i *Indicators) GetEmergency() *bool {
	if i == nil {
		return nil
	}
	return i.Emergency
}

func (i *Indicators) GetC2() *bool {
	if i == nil {
		return nil
	}
	return i.C2
}

func (i *Indicators) GetEgressable() *bool {
	if i == nil {
		return nil
	}
	return i.Egressable
}

func (i *Indicators) GetStarred() *bool {
	if i == nil {
		return nil
	}
	return i.Starred
}

func (i *Indicators) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Indicators) UnmarshalJSON(data []byte) error {
	type unmarshaler Indicators
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Indicators(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Indicators) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// A line of bearing of a signal.
type LineOfBearing struct {
	// The direction pointing from this entity to the detection
	AngleOfArrival *AngleOfArrival `json:"angleOfArrival,omitempty" url:"angleOfArrival,omitempty"`
	// The estimated distance of the detection
	RangeEstimateM *Measurement `json:"rangeEstimateM,omitempty" url:"rangeEstimateM,omitempty"`
	// The maximum distance of the detection
	MaxRangeM *Measurement `json:"maxRangeM,omitempty" url:"maxRangeM,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LineOfBearing) GetAngleOfArrival() *AngleOfArrival {
	if l == nil {
		return nil
	}
	return l.AngleOfArrival
}

func (l *LineOfBearing) GetRangeEstimateM() *Measurement {
	if l == nil {
		return nil
	}
	return l.RangeEstimateM
}

func (l *LineOfBearing) GetMaxRangeM() *Measurement {
	if l == nil {
		return nil
	}
	return l.MaxRangeM
}

func (l *LineOfBearing) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LineOfBearing) UnmarshalJSON(data []byte) error {
	type unmarshaler LineOfBearing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LineOfBearing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LineOfBearing) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A closed ring of points. The first and last point must be the same.
type LinearRing struct {
	Positions []*GeoPolygonPosition `json:"positions,omitempty" url:"positions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LinearRing) GetPositions() []*GeoPolygonPosition {
	if l == nil {
		return nil
	}
	return l.Positions
}

func (l *LinearRing) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LinearRing) UnmarshalJSON(data []byte) error {
	type unmarshaler LinearRing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinearRing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinearRing) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Lla struct {
	Lon  *float64 `json:"lon,omitempty" url:"lon,omitempty"`
	Lat  *float64 `json:"lat,omitempty" url:"lat,omitempty"`
	Alt  *float64 `json:"alt,omitempty" url:"alt,omitempty"`
	Is2D *bool    `json:"is2d,omitempty" url:"is2d,omitempty"`
	// Meaning of alt.
	//
	//	altitude in meters above either WGS84 or EGM96, use altitude_reference to
	//	determine what zero means.
	AltitudeReference *LlaAltitudeReference `json:"altitudeReference,omitempty" url:"altitudeReference,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *Lla) GetLon() *float64 {
	if l == nil {
		return nil
	}
	return l.Lon
}

func (l *Lla) GetLat() *float64 {
	if l == nil {
		return nil
	}
	return l.Lat
}

func (l *Lla) GetAlt() *float64 {
	if l == nil {
		return nil
	}
	return l.Alt
}

func (l *Lla) GetIs2D() *bool {
	if l == nil {
		return nil
	}
	return l.Is2D
}

func (l *Lla) GetAltitudeReference() *LlaAltitudeReference {
	if l == nil {
		return nil
	}
	return l.AltitudeReference
}

func (l *Lla) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Lla) UnmarshalJSON(data []byte) error {
	type unmarshaler Lla
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Lla(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *Lla) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Meaning of alt.
//
//	altitude in meters above either WGS84 or EGM96, use altitude_reference to
//	determine what zero means.
type LlaAltitudeReference string

const (
	LlaAltitudeReferenceAltitudeReferenceInvalid          LlaAltitudeReference = "ALTITUDE_REFERENCE_INVALID"
	LlaAltitudeReferenceAltitudeReferenceHeightAboveWgs84 LlaAltitudeReference = "ALTITUDE_REFERENCE_HEIGHT_ABOVE_WGS84"
	LlaAltitudeReferenceAltitudeReferenceHeightAboveEgm96 LlaAltitudeReference = "ALTITUDE_REFERENCE_HEIGHT_ABOVE_EGM96"
	LlaAltitudeReferenceAltitudeReferenceUnknown          LlaAltitudeReference = "ALTITUDE_REFERENCE_UNKNOWN"
	LlaAltitudeReferenceAltitudeReferenceBarometric       LlaAltitudeReference = "ALTITUDE_REFERENCE_BAROMETRIC"
	LlaAltitudeReferenceAltitudeReferenceAboveSeaFloor    LlaAltitudeReference = "ALTITUDE_REFERENCE_ABOVE_SEA_FLOOR"
	LlaAltitudeReferenceAltitudeReferenceBelowSeaSurface  LlaAltitudeReference = "ALTITUDE_REFERENCE_BELOW_SEA_SURFACE"
)

func NewLlaAltitudeReferenceFromString(s string) (LlaAltitudeReference, error) {
	switch s {
	case "ALTITUDE_REFERENCE_INVALID":
		return LlaAltitudeReferenceAltitudeReferenceInvalid, nil
	case "ALTITUDE_REFERENCE_HEIGHT_ABOVE_WGS84":
		return LlaAltitudeReferenceAltitudeReferenceHeightAboveWgs84, nil
	case "ALTITUDE_REFERENCE_HEIGHT_ABOVE_EGM96":
		return LlaAltitudeReferenceAltitudeReferenceHeightAboveEgm96, nil
	case "ALTITUDE_REFERENCE_UNKNOWN":
		return LlaAltitudeReferenceAltitudeReferenceUnknown, nil
	case "ALTITUDE_REFERENCE_BAROMETRIC":
		return LlaAltitudeReferenceAltitudeReferenceBarometric, nil
	case "ALTITUDE_REFERENCE_ABOVE_SEA_FLOOR":
		return LlaAltitudeReferenceAltitudeReferenceAboveSeaFloor, nil
	case "ALTITUDE_REFERENCE_BELOW_SEA_SURFACE":
		return LlaAltitudeReferenceAltitudeReferenceBelowSeaSurface, nil
	}
	var t LlaAltitudeReference
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LlaAltitudeReference) Ptr() *LlaAltitudeReference {
	return &l
}

// Available for Entities that have a single or primary Location.
type Location struct {
	// see Position definition for details.
	Position *Position `json:"position,omitempty" url:"position,omitempty"`
	// Velocity in an ENU reference frame centered on the corresponding position. All units are meters per second.
	VelocityEnu *Enu `json:"velocityEnu,omitempty" url:"velocityEnu,omitempty"`
	// Speed is the magnitude of velocity_enu vector [sqrt(e^2 + n^2 + u^2)] when present, measured in m/s.
	SpeedMps *float64 `json:"speedMps,omitempty" url:"speedMps,omitempty"`
	// The entity's acceleration in meters/s^2.
	Acceleration *Enu `json:"acceleration,omitempty" url:"acceleration,omitempty"`
	// quaternion to translate from entity body frame to it's ENU frame
	AttitudeEnu *Quaternion `json:"attitudeEnu,omitempty" url:"attitudeEnu,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *Location) GetPosition() *Position {
	if l == nil {
		return nil
	}
	return l.Position
}

func (l *Location) GetVelocityEnu() *Enu {
	if l == nil {
		return nil
	}
	return l.VelocityEnu
}

func (l *Location) GetSpeedMps() *float64 {
	if l == nil {
		return nil
	}
	return l.SpeedMps
}

func (l *Location) GetAcceleration() *Enu {
	if l == nil {
		return nil
	}
	return l.Acceleration
}

func (l *Location) GetAttitudeEnu() *Quaternion {
	if l == nil {
		return nil
	}
	return l.AttitudeEnu
}

func (l *Location) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Location) UnmarshalJSON(data []byte) error {
	type unmarshaler Location
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Location(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *Location) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Uncertainty of entity position and velocity, if available.
type LocationUncertainty struct {
	// Positional covariance represented by the upper triangle of the covariance matrix. It is valid to populate
	//
	//	only the diagonal of the matrix if the full covariance matrix is unknown.
	PositionEnuCov *TMat3 `json:"positionEnuCov,omitempty" url:"positionEnuCov,omitempty"`
	// Velocity covariance represented by the upper triangle of the covariance matrix. It is valid to populate
	//
	//	only the diagonal of the matrix if the full covariance matrix is unknown.
	VelocityEnuCov *TMat3 `json:"velocityEnuCov,omitempty" url:"velocityEnuCov,omitempty"`
	// An ellipse that describes the certainty probability and error boundary for a given geolocation.
	PositionErrorEllipse *ErrorEllipse `json:"positionErrorEllipse,omitempty" url:"positionErrorEllipse,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationUncertainty) GetPositionEnuCov() *TMat3 {
	if l == nil {
		return nil
	}
	return l.PositionEnuCov
}

func (l *LocationUncertainty) GetVelocityEnuCov() *TMat3 {
	if l == nil {
		return nil
	}
	return l.VelocityEnuCov
}

func (l *LocationUncertainty) GetPositionErrorEllipse() *ErrorEllipse {
	if l == nil {
		return nil
	}
	return l.PositionErrorEllipse
}

func (l *LocationUncertainty) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationUncertainty) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationUncertainty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationUncertainty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationUncertainty) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type MeanKeplerianElements struct {
	// UTC time of validity
	Epoch *time.Time `json:"epoch,omitempty" url:"epoch,omitempty"`
	// Preferred: semi major axis in kilometers
	SemiMajorAxisKm *float64 `json:"semiMajorAxisKm,omitempty" url:"semiMajorAxisKm,omitempty"`
	// If using SGP/SGP4, provide the Keplerian Mean Motion in revolutions per day
	MeanMotion   *float64 `json:"meanMotion,omitempty" url:"meanMotion,omitempty"`
	Eccentricity *float64 `json:"eccentricity,omitempty" url:"eccentricity,omitempty"`
	// Angle of inclination in deg
	InclinationDeg *float64 `json:"inclinationDeg,omitempty" url:"inclinationDeg,omitempty"`
	// Right ascension of the ascending node in deg
	RaOfAscNodeDeg *float64 `json:"raOfAscNodeDeg,omitempty" url:"raOfAscNodeDeg,omitempty"`
	// Argument of pericenter in deg
	ArgOfPericenterDeg *float64 `json:"argOfPericenterDeg,omitempty" url:"argOfPericenterDeg,omitempty"`
	// Mean anomaly in deg
	MeanAnomalyDeg *float64 `json:"meanAnomalyDeg,omitempty" url:"meanAnomalyDeg,omitempty"`
	// Optional: gravitational coefficient (Gravitational Constant x central mass) in kg^3 / s^2
	Gm *float64 `json:"gm,omitempty" url:"gm,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MeanKeplerianElements) GetEpoch() *time.Time {
	if m == nil {
		return nil
	}
	return m.Epoch
}

func (m *MeanKeplerianElements) GetSemiMajorAxisKm() *float64 {
	if m == nil {
		return nil
	}
	return m.SemiMajorAxisKm
}

func (m *MeanKeplerianElements) GetMeanMotion() *float64 {
	if m == nil {
		return nil
	}
	return m.MeanMotion
}

func (m *MeanKeplerianElements) GetEccentricity() *float64 {
	if m == nil {
		return nil
	}
	return m.Eccentricity
}

func (m *MeanKeplerianElements) GetInclinationDeg() *float64 {
	if m == nil {
		return nil
	}
	return m.InclinationDeg
}

func (m *MeanKeplerianElements) GetRaOfAscNodeDeg() *float64 {
	if m == nil {
		return nil
	}
	return m.RaOfAscNodeDeg
}

func (m *MeanKeplerianElements) GetArgOfPericenterDeg() *float64 {
	if m == nil {
		return nil
	}
	return m.ArgOfPericenterDeg
}

func (m *MeanKeplerianElements) GetMeanAnomalyDeg() *float64 {
	if m == nil {
		return nil
	}
	return m.MeanAnomalyDeg
}

func (m *MeanKeplerianElements) GetGm() *float64 {
	if m == nil {
		return nil
	}
	return m.Gm
}

func (m *MeanKeplerianElements) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MeanKeplerianElements) UnmarshalJSON(data []byte) error {
	type embed MeanKeplerianElements
	var unmarshaler = struct {
		embed
		Epoch *internal.DateTime `json:"epoch,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MeanKeplerianElements(unmarshaler.embed)
	m.Epoch = unmarshaler.Epoch.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MeanKeplerianElements) MarshalJSON() ([]byte, error) {
	type embed MeanKeplerianElements
	var marshaler = struct {
		embed
		Epoch *internal.DateTime `json:"epoch,omitempty"`
	}{
		embed: embed(*m),
		Epoch: internal.NewOptionalDateTime(m.Epoch),
	}
	return json.Marshal(marshaler)
}

func (m *MeanKeplerianElements) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// A component that describes some measured value with error.
type Measurement struct {
	// The value of the measurement.
	Value *float64 `json:"value,omitempty" url:"value,omitempty"`
	// Estimated one standard deviation in same unit as the value.
	Sigma *float64 `json:"sigma,omitempty" url:"sigma,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Measurement) GetValue() *float64 {
	if m == nil {
		return nil
	}
	return m.Value
}

func (m *Measurement) GetSigma() *float64 {
	if m == nil {
		return nil
	}
	return m.Sigma
}

func (m *Measurement) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Measurement) UnmarshalJSON(data []byte) error {
	type unmarshaler Measurement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Measurement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Measurement) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Media associated with an entity.
type Media struct {
	Media []*MediaItem `json:"media,omitempty" url:"media,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Media) GetMedia() []*MediaItem {
	if m == nil {
		return nil
	}
	return m.Media
}

func (m *Media) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Media) UnmarshalJSON(data []byte) error {
	type unmarshaler Media
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Media(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Media) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MediaItem struct {
	Type *MediaItemType `json:"type,omitempty" url:"type,omitempty"`
	// The path, relative to the environment base URL, where media related to an entity can be accessed
	RelativePath *string `json:"relativePath,omitempty" url:"relativePath,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MediaItem) GetType() *MediaItemType {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MediaItem) GetRelativePath() *string {
	if m == nil {
		return nil
	}
	return m.RelativePath
}

func (m *MediaItem) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MediaItem) UnmarshalJSON(data []byte) error {
	type unmarshaler MediaItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MediaItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MediaItem) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MediaItemType string

const (
	MediaItemTypeMediaTypeInvalid MediaItemType = "MEDIA_TYPE_INVALID"
	MediaItemTypeMediaTypeImage   MediaItemType = "MEDIA_TYPE_IMAGE"
	MediaItemTypeMediaTypeVideo   MediaItemType = "MEDIA_TYPE_VIDEO"
)

func NewMediaItemTypeFromString(s string) (MediaItemType, error) {
	switch s {
	case "MEDIA_TYPE_INVALID":
		return MediaItemTypeMediaTypeInvalid, nil
	case "MEDIA_TYPE_IMAGE":
		return MediaItemTypeMediaTypeImage, nil
	case "MEDIA_TYPE_VIDEO":
		return MediaItemTypeMediaTypeVideo, nil
	}
	var t MediaItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MediaItemType) Ptr() *MediaItemType {
	return &m
}

// A MergedFrom relationship is a uni-directional relationship indicating that this entity is a merged entity whose
//
//	data has at least partially been merged from the related entity.
type MergedFrom struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MergedFrom) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MergedFrom) UnmarshalJSON(data []byte) error {
	type unmarshaler MergedFrom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MergedFrom(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MergedFrom) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Provides the disposition, environment, and nationality of an Entity.
type MilView struct {
	Disposition *MilViewDisposition `json:"disposition,omitempty" url:"disposition,omitempty"`
	Environment *MilViewEnvironment `json:"environment,omitempty" url:"environment,omitempty"`
	Nationality *MilViewNationality `json:"nationality,omitempty" url:"nationality,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MilView) GetDisposition() *MilViewDisposition {
	if m == nil {
		return nil
	}
	return m.Disposition
}

func (m *MilView) GetEnvironment() *MilViewEnvironment {
	if m == nil {
		return nil
	}
	return m.Environment
}

func (m *MilView) GetNationality() *MilViewNationality {
	if m == nil {
		return nil
	}
	return m.Nationality
}

func (m *MilView) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MilView) UnmarshalJSON(data []byte) error {
	type unmarshaler MilView
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MilView(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MilView) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MilViewDisposition string

const (
	MilViewDispositionDispositionUnknown         MilViewDisposition = "DISPOSITION_UNKNOWN"
	MilViewDispositionDispositionFriendly        MilViewDisposition = "DISPOSITION_FRIENDLY"
	MilViewDispositionDispositionHostile         MilViewDisposition = "DISPOSITION_HOSTILE"
	MilViewDispositionDispositionSuspicious      MilViewDisposition = "DISPOSITION_SUSPICIOUS"
	MilViewDispositionDispositionAssumedFriendly MilViewDisposition = "DISPOSITION_ASSUMED_FRIENDLY"
	MilViewDispositionDispositionNeutral         MilViewDisposition = "DISPOSITION_NEUTRAL"
	MilViewDispositionDispositionPending         MilViewDisposition = "DISPOSITION_PENDING"
)

func NewMilViewDispositionFromString(s string) (MilViewDisposition, error) {
	switch s {
	case "DISPOSITION_UNKNOWN":
		return MilViewDispositionDispositionUnknown, nil
	case "DISPOSITION_FRIENDLY":
		return MilViewDispositionDispositionFriendly, nil
	case "DISPOSITION_HOSTILE":
		return MilViewDispositionDispositionHostile, nil
	case "DISPOSITION_SUSPICIOUS":
		return MilViewDispositionDispositionSuspicious, nil
	case "DISPOSITION_ASSUMED_FRIENDLY":
		return MilViewDispositionDispositionAssumedFriendly, nil
	case "DISPOSITION_NEUTRAL":
		return MilViewDispositionDispositionNeutral, nil
	case "DISPOSITION_PENDING":
		return MilViewDispositionDispositionPending, nil
	}
	var t MilViewDisposition
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MilViewDisposition) Ptr() *MilViewDisposition {
	return &m
}

type MilViewEnvironment string

const (
	MilViewEnvironmentEnvironmentUnknown    MilViewEnvironment = "ENVIRONMENT_UNKNOWN"
	MilViewEnvironmentEnvironmentAir        MilViewEnvironment = "ENVIRONMENT_AIR"
	MilViewEnvironmentEnvironmentSurface    MilViewEnvironment = "ENVIRONMENT_SURFACE"
	MilViewEnvironmentEnvironmentSubSurface MilViewEnvironment = "ENVIRONMENT_SUB_SURFACE"
	MilViewEnvironmentEnvironmentLand       MilViewEnvironment = "ENVIRONMENT_LAND"
	MilViewEnvironmentEnvironmentSpace      MilViewEnvironment = "ENVIRONMENT_SPACE"
)

func NewMilViewEnvironmentFromString(s string) (MilViewEnvironment, error) {
	switch s {
	case "ENVIRONMENT_UNKNOWN":
		return MilViewEnvironmentEnvironmentUnknown, nil
	case "ENVIRONMENT_AIR":
		return MilViewEnvironmentEnvironmentAir, nil
	case "ENVIRONMENT_SURFACE":
		return MilViewEnvironmentEnvironmentSurface, nil
	case "ENVIRONMENT_SUB_SURFACE":
		return MilViewEnvironmentEnvironmentSubSurface, nil
	case "ENVIRONMENT_LAND":
		return MilViewEnvironmentEnvironmentLand, nil
	case "ENVIRONMENT_SPACE":
		return MilViewEnvironmentEnvironmentSpace, nil
	}
	var t MilViewEnvironment
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MilViewEnvironment) Ptr() *MilViewEnvironment {
	return &m
}

type MilViewNationality string

const (
	MilViewNationalityNationalityInvalid                              MilViewNationality = "NATIONALITY_INVALID"
	MilViewNationalityNationalityAlbania                              MilViewNationality = "NATIONALITY_ALBANIA"
	MilViewNationalityNationalityAlgeria                              MilViewNationality = "NATIONALITY_ALGERIA"
	MilViewNationalityNationalityArgentina                            MilViewNationality = "NATIONALITY_ARGENTINA"
	MilViewNationalityNationalityArmenia                              MilViewNationality = "NATIONALITY_ARMENIA"
	MilViewNationalityNationalityAustralia                            MilViewNationality = "NATIONALITY_AUSTRALIA"
	MilViewNationalityNationalityAustria                              MilViewNationality = "NATIONALITY_AUSTRIA"
	MilViewNationalityNationalityAzerbaijan                           MilViewNationality = "NATIONALITY_AZERBAIJAN"
	MilViewNationalityNationalityBelarus                              MilViewNationality = "NATIONALITY_BELARUS"
	MilViewNationalityNationalityBelgium                              MilViewNationality = "NATIONALITY_BELGIUM"
	MilViewNationalityNationalityBolivia                              MilViewNationality = "NATIONALITY_BOLIVIA"
	MilViewNationalityNationalityBosniaAndHerzegovina                 MilViewNationality = "NATIONALITY_BOSNIA_AND_HERZEGOVINA"
	MilViewNationalityNationalityBrazil                               MilViewNationality = "NATIONALITY_BRAZIL"
	MilViewNationalityNationalityBulgaria                             MilViewNationality = "NATIONALITY_BULGARIA"
	MilViewNationalityNationalityCambodia                             MilViewNationality = "NATIONALITY_CAMBODIA"
	MilViewNationalityNationalityCanada                               MilViewNationality = "NATIONALITY_CANADA"
	MilViewNationalityNationalityChile                                MilViewNationality = "NATIONALITY_CHILE"
	MilViewNationalityNationalityChina                                MilViewNationality = "NATIONALITY_CHINA"
	MilViewNationalityNationalityColombia                             MilViewNationality = "NATIONALITY_COLOMBIA"
	MilViewNationalityNationalityCroatia                              MilViewNationality = "NATIONALITY_CROATIA"
	MilViewNationalityNationalityCuba                                 MilViewNationality = "NATIONALITY_CUBA"
	MilViewNationalityNationalityCyprus                               MilViewNationality = "NATIONALITY_CYPRUS"
	MilViewNationalityNationalityCzechRepublic                        MilViewNationality = "NATIONALITY_CZECH_REPUBLIC"
	MilViewNationalityNationalityDemocraticPeoplesRepublicOfKorea     MilViewNationality = "NATIONALITY_DEMOCRATIC_PEOPLES_REPUBLIC_OF_KOREA"
	MilViewNationalityNationalityDenmark                              MilViewNationality = "NATIONALITY_DENMARK"
	MilViewNationalityNationalityDominicanRepublic                    MilViewNationality = "NATIONALITY_DOMINICAN_REPUBLIC"
	MilViewNationalityNationalityEcuador                              MilViewNationality = "NATIONALITY_ECUADOR"
	MilViewNationalityNationalityEgypt                                MilViewNationality = "NATIONALITY_EGYPT"
	MilViewNationalityNationalityEstonia                              MilViewNationality = "NATIONALITY_ESTONIA"
	MilViewNationalityNationalityEthiopia                             MilViewNationality = "NATIONALITY_ETHIOPIA"
	MilViewNationalityNationalityFinland                              MilViewNationality = "NATIONALITY_FINLAND"
	MilViewNationalityNationalityFrance                               MilViewNationality = "NATIONALITY_FRANCE"
	MilViewNationalityNationalityGeorgia                              MilViewNationality = "NATIONALITY_GEORGIA"
	MilViewNationalityNationalityGermany                              MilViewNationality = "NATIONALITY_GERMANY"
	MilViewNationalityNationalityGreece                               MilViewNationality = "NATIONALITY_GREECE"
	MilViewNationalityNationalityGuatemala                            MilViewNationality = "NATIONALITY_GUATEMALA"
	MilViewNationalityNationalityGuinea                               MilViewNationality = "NATIONALITY_GUINEA"
	MilViewNationalityNationalityHungary                              MilViewNationality = "NATIONALITY_HUNGARY"
	MilViewNationalityNationalityIceland                              MilViewNationality = "NATIONALITY_ICELAND"
	MilViewNationalityNationalityIndia                                MilViewNationality = "NATIONALITY_INDIA"
	MilViewNationalityNationalityIndonesia                            MilViewNationality = "NATIONALITY_INDONESIA"
	MilViewNationalityNationalityInternationalRedCross                MilViewNationality = "NATIONALITY_INTERNATIONAL_RED_CROSS"
	MilViewNationalityNationalityIraq                                 MilViewNationality = "NATIONALITY_IRAQ"
	MilViewNationalityNationalityIreland                              MilViewNationality = "NATIONALITY_IRELAND"
	MilViewNationalityNationalityIslamicRepublicOfIran                MilViewNationality = "NATIONALITY_ISLAMIC_REPUBLIC_OF_IRAN"
	MilViewNationalityNationalityIsrael                               MilViewNationality = "NATIONALITY_ISRAEL"
	MilViewNationalityNationalityItaly                                MilViewNationality = "NATIONALITY_ITALY"
	MilViewNationalityNationalityJamaica                              MilViewNationality = "NATIONALITY_JAMAICA"
	MilViewNationalityNationalityJapan                                MilViewNationality = "NATIONALITY_JAPAN"
	MilViewNationalityNationalityJordan                               MilViewNationality = "NATIONALITY_JORDAN"
	MilViewNationalityNationalityKazakhstan                           MilViewNationality = "NATIONALITY_KAZAKHSTAN"
	MilViewNationalityNationalityKuwait                               MilViewNationality = "NATIONALITY_KUWAIT"
	MilViewNationalityNationalityKyrghyzRepublic                      MilViewNationality = "NATIONALITY_KYRGHYZ_REPUBLIC"
	MilViewNationalityNationalityLaoPeoplesDemocraticRepublic         MilViewNationality = "NATIONALITY_LAO_PEOPLES_DEMOCRATIC_REPUBLIC"
	MilViewNationalityNationalityLatvia                               MilViewNationality = "NATIONALITY_LATVIA"
	MilViewNationalityNationalityLebanon                              MilViewNationality = "NATIONALITY_LEBANON"
	MilViewNationalityNationalityLiberia                              MilViewNationality = "NATIONALITY_LIBERIA"
	MilViewNationalityNationalityLithuania                            MilViewNationality = "NATIONALITY_LITHUANIA"
	MilViewNationalityNationalityLuxembourg                           MilViewNationality = "NATIONALITY_LUXEMBOURG"
	MilViewNationalityNationalityMadagascar                           MilViewNationality = "NATIONALITY_MADAGASCAR"
	MilViewNationalityNationalityMalaysia                             MilViewNationality = "NATIONALITY_MALAYSIA"
	MilViewNationalityNationalityMalta                                MilViewNationality = "NATIONALITY_MALTA"
	MilViewNationalityNationalityMexico                               MilViewNationality = "NATIONALITY_MEXICO"
	MilViewNationalityNationalityMoldova                              MilViewNationality = "NATIONALITY_MOLDOVA"
	MilViewNationalityNationalityMontenegro                           MilViewNationality = "NATIONALITY_MONTENEGRO"
	MilViewNationalityNationalityMorocco                              MilViewNationality = "NATIONALITY_MOROCCO"
	MilViewNationalityNationalityMyanmar                              MilViewNationality = "NATIONALITY_MYANMAR"
	MilViewNationalityNationalityNato                                 MilViewNationality = "NATIONALITY_NATO"
	MilViewNationalityNationalityNetherlands                          MilViewNationality = "NATIONALITY_NETHERLANDS"
	MilViewNationalityNationalityNewZealand                           MilViewNationality = "NATIONALITY_NEW_ZEALAND"
	MilViewNationalityNationalityNicaragua                            MilViewNationality = "NATIONALITY_NICARAGUA"
	MilViewNationalityNationalityNigeria                              MilViewNationality = "NATIONALITY_NIGERIA"
	MilViewNationalityNationalityNorway                               MilViewNationality = "NATIONALITY_NORWAY"
	MilViewNationalityNationalityPakistan                             MilViewNationality = "NATIONALITY_PAKISTAN"
	MilViewNationalityNationalityPanama                               MilViewNationality = "NATIONALITY_PANAMA"
	MilViewNationalityNationalityParaguay                             MilViewNationality = "NATIONALITY_PARAGUAY"
	MilViewNationalityNationalityPeru                                 MilViewNationality = "NATIONALITY_PERU"
	MilViewNationalityNationalityPhilippines                          MilViewNationality = "NATIONALITY_PHILIPPINES"
	MilViewNationalityNationalityPoland                               MilViewNationality = "NATIONALITY_POLAND"
	MilViewNationalityNationalityPortugal                             MilViewNationality = "NATIONALITY_PORTUGAL"
	MilViewNationalityNationalityRepublicOfKorea                      MilViewNationality = "NATIONALITY_REPUBLIC_OF_KOREA"
	MilViewNationalityNationalityRomania                              MilViewNationality = "NATIONALITY_ROMANIA"
	MilViewNationalityNationalityRussia                               MilViewNationality = "NATIONALITY_RUSSIA"
	MilViewNationalityNationalitySaudiArabia                          MilViewNationality = "NATIONALITY_SAUDI_ARABIA"
	MilViewNationalityNationalitySenegal                              MilViewNationality = "NATIONALITY_SENEGAL"
	MilViewNationalityNationalitySerbia                               MilViewNationality = "NATIONALITY_SERBIA"
	MilViewNationalityNationalitySingapore                            MilViewNationality = "NATIONALITY_SINGAPORE"
	MilViewNationalityNationalitySlovakia                             MilViewNationality = "NATIONALITY_SLOVAKIA"
	MilViewNationalityNationalitySlovenia                             MilViewNationality = "NATIONALITY_SLOVENIA"
	MilViewNationalityNationalitySouthAfrica                          MilViewNationality = "NATIONALITY_SOUTH_AFRICA"
	MilViewNationalityNationalitySpain                                MilViewNationality = "NATIONALITY_SPAIN"
	MilViewNationalityNationalitySudan                                MilViewNationality = "NATIONALITY_SUDAN"
	MilViewNationalityNationalitySweden                               MilViewNationality = "NATIONALITY_SWEDEN"
	MilViewNationalityNationalitySwitzerland                          MilViewNationality = "NATIONALITY_SWITZERLAND"
	MilViewNationalityNationalitySyrianArabRepublic                   MilViewNationality = "NATIONALITY_SYRIAN_ARAB_REPUBLIC"
	MilViewNationalityNationalityTaiwan                               MilViewNationality = "NATIONALITY_TAIWAN"
	MilViewNationalityNationalityTajikistan                           MilViewNationality = "NATIONALITY_TAJIKISTAN"
	MilViewNationalityNationalityThailand                             MilViewNationality = "NATIONALITY_THAILAND"
	MilViewNationalityNationalityTheFormerYugoslavRepublicOfMacedonia MilViewNationality = "NATIONALITY_THE_FORMER_YUGOSLAV_REPUBLIC_OF_MACEDONIA"
	MilViewNationalityNationalityTunisia                              MilViewNationality = "NATIONALITY_TUNISIA"
	MilViewNationalityNationalityTurkey                               MilViewNationality = "NATIONALITY_TURKEY"
	MilViewNationalityNationalityTurkmenistan                         MilViewNationality = "NATIONALITY_TURKMENISTAN"
	MilViewNationalityNationalityUganda                               MilViewNationality = "NATIONALITY_UGANDA"
	MilViewNationalityNationalityUkraine                              MilViewNationality = "NATIONALITY_UKRAINE"
	MilViewNationalityNationalityUnitedKingdom                        MilViewNationality = "NATIONALITY_UNITED_KINGDOM"
	MilViewNationalityNationalityUnitedNations                        MilViewNationality = "NATIONALITY_UNITED_NATIONS"
	MilViewNationalityNationalityUnitedRepublicOfTanzania             MilViewNationality = "NATIONALITY_UNITED_REPUBLIC_OF_TANZANIA"
	MilViewNationalityNationalityUnitedStatesOfAmerica                MilViewNationality = "NATIONALITY_UNITED_STATES_OF_AMERICA"
	MilViewNationalityNationalityUruguay                              MilViewNationality = "NATIONALITY_URUGUAY"
	MilViewNationalityNationalityUzbekistan                           MilViewNationality = "NATIONALITY_UZBEKISTAN"
	MilViewNationalityNationalityVenezuela                            MilViewNationality = "NATIONALITY_VENEZUELA"
	MilViewNationalityNationalityVietnam                              MilViewNationality = "NATIONALITY_VIETNAM"
	MilViewNationalityNationalityYemen                                MilViewNationality = "NATIONALITY_YEMEN"
	MilViewNationalityNationalityZimbabwe                             MilViewNationality = "NATIONALITY_ZIMBABWE"
)

func NewMilViewNationalityFromString(s string) (MilViewNationality, error) {
	switch s {
	case "NATIONALITY_INVALID":
		return MilViewNationalityNationalityInvalid, nil
	case "NATIONALITY_ALBANIA":
		return MilViewNationalityNationalityAlbania, nil
	case "NATIONALITY_ALGERIA":
		return MilViewNationalityNationalityAlgeria, nil
	case "NATIONALITY_ARGENTINA":
		return MilViewNationalityNationalityArgentina, nil
	case "NATIONALITY_ARMENIA":
		return MilViewNationalityNationalityArmenia, nil
	case "NATIONALITY_AUSTRALIA":
		return MilViewNationalityNationalityAustralia, nil
	case "NATIONALITY_AUSTRIA":
		return MilViewNationalityNationalityAustria, nil
	case "NATIONALITY_AZERBAIJAN":
		return MilViewNationalityNationalityAzerbaijan, nil
	case "NATIONALITY_BELARUS":
		return MilViewNationalityNationalityBelarus, nil
	case "NATIONALITY_BELGIUM":
		return MilViewNationalityNationalityBelgium, nil
	case "NATIONALITY_BOLIVIA":
		return MilViewNationalityNationalityBolivia, nil
	case "NATIONALITY_BOSNIA_AND_HERZEGOVINA":
		return MilViewNationalityNationalityBosniaAndHerzegovina, nil
	case "NATIONALITY_BRAZIL":
		return MilViewNationalityNationalityBrazil, nil
	case "NATIONALITY_BULGARIA":
		return MilViewNationalityNationalityBulgaria, nil
	case "NATIONALITY_CAMBODIA":
		return MilViewNationalityNationalityCambodia, nil
	case "NATIONALITY_CANADA":
		return MilViewNationalityNationalityCanada, nil
	case "NATIONALITY_CHILE":
		return MilViewNationalityNationalityChile, nil
	case "NATIONALITY_CHINA":
		return MilViewNationalityNationalityChina, nil
	case "NATIONALITY_COLOMBIA":
		return MilViewNationalityNationalityColombia, nil
	case "NATIONALITY_CROATIA":
		return MilViewNationalityNationalityCroatia, nil
	case "NATIONALITY_CUBA":
		return MilViewNationalityNationalityCuba, nil
	case "NATIONALITY_CYPRUS":
		return MilViewNationalityNationalityCyprus, nil
	case "NATIONALITY_CZECH_REPUBLIC":
		return MilViewNationalityNationalityCzechRepublic, nil
	case "NATIONALITY_DEMOCRATIC_PEOPLES_REPUBLIC_OF_KOREA":
		return MilViewNationalityNationalityDemocraticPeoplesRepublicOfKorea, nil
	case "NATIONALITY_DENMARK":
		return MilViewNationalityNationalityDenmark, nil
	case "NATIONALITY_DOMINICAN_REPUBLIC":
		return MilViewNationalityNationalityDominicanRepublic, nil
	case "NATIONALITY_ECUADOR":
		return MilViewNationalityNationalityEcuador, nil
	case "NATIONALITY_EGYPT":
		return MilViewNationalityNationalityEgypt, nil
	case "NATIONALITY_ESTONIA":
		return MilViewNationalityNationalityEstonia, nil
	case "NATIONALITY_ETHIOPIA":
		return MilViewNationalityNationalityEthiopia, nil
	case "NATIONALITY_FINLAND":
		return MilViewNationalityNationalityFinland, nil
	case "NATIONALITY_FRANCE":
		return MilViewNationalityNationalityFrance, nil
	case "NATIONALITY_GEORGIA":
		return MilViewNationalityNationalityGeorgia, nil
	case "NATIONALITY_GERMANY":
		return MilViewNationalityNationalityGermany, nil
	case "NATIONALITY_GREECE":
		return MilViewNationalityNationalityGreece, nil
	case "NATIONALITY_GUATEMALA":
		return MilViewNationalityNationalityGuatemala, nil
	case "NATIONALITY_GUINEA":
		return MilViewNationalityNationalityGuinea, nil
	case "NATIONALITY_HUNGARY":
		return MilViewNationalityNationalityHungary, nil
	case "NATIONALITY_ICELAND":
		return MilViewNationalityNationalityIceland, nil
	case "NATIONALITY_INDIA":
		return MilViewNationalityNationalityIndia, nil
	case "NATIONALITY_INDONESIA":
		return MilViewNationalityNationalityIndonesia, nil
	case "NATIONALITY_INTERNATIONAL_RED_CROSS":
		return MilViewNationalityNationalityInternationalRedCross, nil
	case "NATIONALITY_IRAQ":
		return MilViewNationalityNationalityIraq, nil
	case "NATIONALITY_IRELAND":
		return MilViewNationalityNationalityIreland, nil
	case "NATIONALITY_ISLAMIC_REPUBLIC_OF_IRAN":
		return MilViewNationalityNationalityIslamicRepublicOfIran, nil
	case "NATIONALITY_ISRAEL":
		return MilViewNationalityNationalityIsrael, nil
	case "NATIONALITY_ITALY":
		return MilViewNationalityNationalityItaly, nil
	case "NATIONALITY_JAMAICA":
		return MilViewNationalityNationalityJamaica, nil
	case "NATIONALITY_JAPAN":
		return MilViewNationalityNationalityJapan, nil
	case "NATIONALITY_JORDAN":
		return MilViewNationalityNationalityJordan, nil
	case "NATIONALITY_KAZAKHSTAN":
		return MilViewNationalityNationalityKazakhstan, nil
	case "NATIONALITY_KUWAIT":
		return MilViewNationalityNationalityKuwait, nil
	case "NATIONALITY_KYRGHYZ_REPUBLIC":
		return MilViewNationalityNationalityKyrghyzRepublic, nil
	case "NATIONALITY_LAO_PEOPLES_DEMOCRATIC_REPUBLIC":
		return MilViewNationalityNationalityLaoPeoplesDemocraticRepublic, nil
	case "NATIONALITY_LATVIA":
		return MilViewNationalityNationalityLatvia, nil
	case "NATIONALITY_LEBANON":
		return MilViewNationalityNationalityLebanon, nil
	case "NATIONALITY_LIBERIA":
		return MilViewNationalityNationalityLiberia, nil
	case "NATIONALITY_LITHUANIA":
		return MilViewNationalityNationalityLithuania, nil
	case "NATIONALITY_LUXEMBOURG":
		return MilViewNationalityNationalityLuxembourg, nil
	case "NATIONALITY_MADAGASCAR":
		return MilViewNationalityNationalityMadagascar, nil
	case "NATIONALITY_MALAYSIA":
		return MilViewNationalityNationalityMalaysia, nil
	case "NATIONALITY_MALTA":
		return MilViewNationalityNationalityMalta, nil
	case "NATIONALITY_MEXICO":
		return MilViewNationalityNationalityMexico, nil
	case "NATIONALITY_MOLDOVA":
		return MilViewNationalityNationalityMoldova, nil
	case "NATIONALITY_MONTENEGRO":
		return MilViewNationalityNationalityMontenegro, nil
	case "NATIONALITY_MOROCCO":
		return MilViewNationalityNationalityMorocco, nil
	case "NATIONALITY_MYANMAR":
		return MilViewNationalityNationalityMyanmar, nil
	case "NATIONALITY_NATO":
		return MilViewNationalityNationalityNato, nil
	case "NATIONALITY_NETHERLANDS":
		return MilViewNationalityNationalityNetherlands, nil
	case "NATIONALITY_NEW_ZEALAND":
		return MilViewNationalityNationalityNewZealand, nil
	case "NATIONALITY_NICARAGUA":
		return MilViewNationalityNationalityNicaragua, nil
	case "NATIONALITY_NIGERIA":
		return MilViewNationalityNationalityNigeria, nil
	case "NATIONALITY_NORWAY":
		return MilViewNationalityNationalityNorway, nil
	case "NATIONALITY_PAKISTAN":
		return MilViewNationalityNationalityPakistan, nil
	case "NATIONALITY_PANAMA":
		return MilViewNationalityNationalityPanama, nil
	case "NATIONALITY_PARAGUAY":
		return MilViewNationalityNationalityParaguay, nil
	case "NATIONALITY_PERU":
		return MilViewNationalityNationalityPeru, nil
	case "NATIONALITY_PHILIPPINES":
		return MilViewNationalityNationalityPhilippines, nil
	case "NATIONALITY_POLAND":
		return MilViewNationalityNationalityPoland, nil
	case "NATIONALITY_PORTUGAL":
		return MilViewNationalityNationalityPortugal, nil
	case "NATIONALITY_REPUBLIC_OF_KOREA":
		return MilViewNationalityNationalityRepublicOfKorea, nil
	case "NATIONALITY_ROMANIA":
		return MilViewNationalityNationalityRomania, nil
	case "NATIONALITY_RUSSIA":
		return MilViewNationalityNationalityRussia, nil
	case "NATIONALITY_SAUDI_ARABIA":
		return MilViewNationalityNationalitySaudiArabia, nil
	case "NATIONALITY_SENEGAL":
		return MilViewNationalityNationalitySenegal, nil
	case "NATIONALITY_SERBIA":
		return MilViewNationalityNationalitySerbia, nil
	case "NATIONALITY_SINGAPORE":
		return MilViewNationalityNationalitySingapore, nil
	case "NATIONALITY_SLOVAKIA":
		return MilViewNationalityNationalitySlovakia, nil
	case "NATIONALITY_SLOVENIA":
		return MilViewNationalityNationalitySlovenia, nil
	case "NATIONALITY_SOUTH_AFRICA":
		return MilViewNationalityNationalitySouthAfrica, nil
	case "NATIONALITY_SPAIN":
		return MilViewNationalityNationalitySpain, nil
	case "NATIONALITY_SUDAN":
		return MilViewNationalityNationalitySudan, nil
	case "NATIONALITY_SWEDEN":
		return MilViewNationalityNationalitySweden, nil
	case "NATIONALITY_SWITZERLAND":
		return MilViewNationalityNationalitySwitzerland, nil
	case "NATIONALITY_SYRIAN_ARAB_REPUBLIC":
		return MilViewNationalityNationalitySyrianArabRepublic, nil
	case "NATIONALITY_TAIWAN":
		return MilViewNationalityNationalityTaiwan, nil
	case "NATIONALITY_TAJIKISTAN":
		return MilViewNationalityNationalityTajikistan, nil
	case "NATIONALITY_THAILAND":
		return MilViewNationalityNationalityThailand, nil
	case "NATIONALITY_THE_FORMER_YUGOSLAV_REPUBLIC_OF_MACEDONIA":
		return MilViewNationalityNationalityTheFormerYugoslavRepublicOfMacedonia, nil
	case "NATIONALITY_TUNISIA":
		return MilViewNationalityNationalityTunisia, nil
	case "NATIONALITY_TURKEY":
		return MilViewNationalityNationalityTurkey, nil
	case "NATIONALITY_TURKMENISTAN":
		return MilViewNationalityNationalityTurkmenistan, nil
	case "NATIONALITY_UGANDA":
		return MilViewNationalityNationalityUganda, nil
	case "NATIONALITY_UKRAINE":
		return MilViewNationalityNationalityUkraine, nil
	case "NATIONALITY_UNITED_KINGDOM":
		return MilViewNationalityNationalityUnitedKingdom, nil
	case "NATIONALITY_UNITED_NATIONS":
		return MilViewNationalityNationalityUnitedNations, nil
	case "NATIONALITY_UNITED_REPUBLIC_OF_TANZANIA":
		return MilViewNationalityNationalityUnitedRepublicOfTanzania, nil
	case "NATIONALITY_UNITED_STATES_OF_AMERICA":
		return MilViewNationalityNationalityUnitedStatesOfAmerica, nil
	case "NATIONALITY_URUGUAY":
		return MilViewNationalityNationalityUruguay, nil
	case "NATIONALITY_UZBEKISTAN":
		return MilViewNationalityNationalityUzbekistan, nil
	case "NATIONALITY_VENEZUELA":
		return MilViewNationalityNationalityVenezuela, nil
	case "NATIONALITY_VIETNAM":
		return MilViewNationalityNationalityVietnam, nil
	case "NATIONALITY_YEMEN":
		return MilViewNationalityNationalityYemen, nil
	case "NATIONALITY_ZIMBABWE":
		return MilViewNationalityNationalityZimbabwe, nil
	}
	var t MilViewNationality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MilViewNationality) Ptr() *MilViewNationality {
	return &m
}

// Describes the Mode 5 transponder interrogation status and codes.
type Mode5 struct {
	// The validity of the response from the Mode 5 interrogation.
	Mode5InterrogationResponse *Mode5Mode5InterrogationResponse `json:"mode5InterrogationResponse,omitempty" url:"mode5InterrogationResponse,omitempty"`
	// The Mode 5 code assigned to military assets.
	Mode5 *int `json:"mode5,omitempty" url:"mode5,omitempty"`
	// The Mode 5 platform identification code.
	Mode5PlatformID *int `json:"mode5PlatformId,omitempty" url:"mode5PlatformId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Mode5) GetMode5InterrogationResponse() *Mode5Mode5InterrogationResponse {
	if m == nil {
		return nil
	}
	return m.Mode5InterrogationResponse
}

func (m *Mode5) GetMode5() *int {
	if m == nil {
		return nil
	}
	return m.Mode5
}

func (m *Mode5) GetMode5PlatformID() *int {
	if m == nil {
		return nil
	}
	return m.Mode5PlatformID
}

func (m *Mode5) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Mode5) UnmarshalJSON(data []byte) error {
	type unmarshaler Mode5
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Mode5(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Mode5) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The validity of the response from the Mode 5 interrogation.
type Mode5Mode5InterrogationResponse string

const (
	Mode5Mode5InterrogationResponseInterrogationResponseInvalid    Mode5Mode5InterrogationResponse = "INTERROGATION_RESPONSE_INVALID"
	Mode5Mode5InterrogationResponseInterrogationResponseCorrect    Mode5Mode5InterrogationResponse = "INTERROGATION_RESPONSE_CORRECT"
	Mode5Mode5InterrogationResponseInterrogationResponseIncorrect  Mode5Mode5InterrogationResponse = "INTERROGATION_RESPONSE_INCORRECT"
	Mode5Mode5InterrogationResponseInterrogationResponseNoResponse Mode5Mode5InterrogationResponse = "INTERROGATION_RESPONSE_NO_RESPONSE"
)

func NewMode5Mode5InterrogationResponseFromString(s string) (Mode5Mode5InterrogationResponse, error) {
	switch s {
	case "INTERROGATION_RESPONSE_INVALID":
		return Mode5Mode5InterrogationResponseInterrogationResponseInvalid, nil
	case "INTERROGATION_RESPONSE_CORRECT":
		return Mode5Mode5InterrogationResponseInterrogationResponseCorrect, nil
	case "INTERROGATION_RESPONSE_INCORRECT":
		return Mode5Mode5InterrogationResponseInterrogationResponseIncorrect, nil
	case "INTERROGATION_RESPONSE_NO_RESPONSE":
		return Mode5Mode5InterrogationResponseInterrogationResponseNoResponse, nil
	}
	var t Mode5Mode5InterrogationResponse
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m Mode5Mode5InterrogationResponse) Ptr() *Mode5Mode5InterrogationResponse {
	return &m
}

// Describes the Mode S codes.
type ModeS struct {
	// Mode S identifier which comprises of 8 alphanumeric characters.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The Mode S ICAO aircraft address. Expected values are between 1 and 16777214 decimal. The Mode S address is
	//
	//	considered unique.
	Address *int `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModeS) GetID() *string {
	if m == nil {
		return nil
	}
	return m.ID
}

func (m *ModeS) GetAddress() *int {
	if m == nil {
		return nil
	}
	return m.Address
}

func (m *ModeS) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModeS) UnmarshalJSON(data []byte) error {
	type unmarshaler ModeS
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModeS(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModeS) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NonPrimaryMembership struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NonPrimaryMembership) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NonPrimaryMembership) UnmarshalJSON(data []byte) error {
	type unmarshaler NonPrimaryMembership
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NonPrimaryMembership(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NonPrimaryMembership) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Ontology of the entity.
type Ontology struct {
	// A string that describes the entity's high-level type with natural language.
	PlatformType *string `json:"platformType,omitempty" url:"platformType,omitempty"`
	// A string that describes the entity's exact model or type.
	SpecificType *string `json:"specificType,omitempty" url:"specificType,omitempty"`
	// The template used when creating this entity. Specifies minimum required components.
	Template *OntologyTemplate `json:"template,omitempty" url:"template,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Ontology) GetPlatformType() *string {
	if o == nil {
		return nil
	}
	return o.PlatformType
}

func (o *Ontology) GetSpecificType() *string {
	if o == nil {
		return nil
	}
	return o.SpecificType
}

func (o *Ontology) GetTemplate() *OntologyTemplate {
	if o == nil {
		return nil
	}
	return o.Template
}

func (o *Ontology) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Ontology) UnmarshalJSON(data []byte) error {
	type unmarshaler Ontology
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Ontology(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Ontology) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The template used when creating this entity. Specifies minimum required components.
type OntologyTemplate string

const (
	OntologyTemplateTemplateInvalid               OntologyTemplate = "TEMPLATE_INVALID"
	OntologyTemplateTemplateTrack                 OntologyTemplate = "TEMPLATE_TRACK"
	OntologyTemplateTemplateSensorPointOfInterest OntologyTemplate = "TEMPLATE_SENSOR_POINT_OF_INTEREST"
	OntologyTemplateTemplateAsset                 OntologyTemplate = "TEMPLATE_ASSET"
	OntologyTemplateTemplateGeo                   OntologyTemplate = "TEMPLATE_GEO"
	OntologyTemplateTemplateSignalOfInterest      OntologyTemplate = "TEMPLATE_SIGNAL_OF_INTEREST"
)

func NewOntologyTemplateFromString(s string) (OntologyTemplate, error) {
	switch s {
	case "TEMPLATE_INVALID":
		return OntologyTemplateTemplateInvalid, nil
	case "TEMPLATE_TRACK":
		return OntologyTemplateTemplateTrack, nil
	case "TEMPLATE_SENSOR_POINT_OF_INTEREST":
		return OntologyTemplateTemplateSensorPointOfInterest, nil
	case "TEMPLATE_ASSET":
		return OntologyTemplateTemplateAsset, nil
	case "TEMPLATE_GEO":
		return OntologyTemplateTemplateGeo, nil
	case "TEMPLATE_SIGNAL_OF_INTEREST":
		return OntologyTemplateTemplateSignalOfInterest, nil
	}
	var t OntologyTemplate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OntologyTemplate) Ptr() *OntologyTemplate {
	return &o
}

type Orbit struct {
	// Orbit Mean Elements data, analogous to the Orbit Mean Elements Message in CCSDS 502.0-B-3
	OrbitMeanElements *OrbitMeanElements `json:"orbitMeanElements,omitempty" url:"orbitMeanElements,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Orbit) GetOrbitMeanElements() *OrbitMeanElements {
	if o == nil {
		return nil
	}
	return o.OrbitMeanElements
}

func (o *Orbit) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Orbit) UnmarshalJSON(data []byte) error {
	type unmarshaler Orbit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Orbit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Orbit) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Orbit Mean Elements data, analogous to the Orbit Mean Elements Message in CCSDS 502.0-B-3
type OrbitMeanElements struct {
	Metadata              *OrbitMeanElementsMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	MeanKeplerianElements *MeanKeplerianElements     `json:"meanKeplerianElements,omitempty" url:"meanKeplerianElements,omitempty"`
	TleParameters         *TleParameters             `json:"tleParameters,omitempty" url:"tleParameters,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrbitMeanElements) GetMetadata() *OrbitMeanElementsMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *OrbitMeanElements) GetMeanKeplerianElements() *MeanKeplerianElements {
	if o == nil {
		return nil
	}
	return o.MeanKeplerianElements
}

func (o *OrbitMeanElements) GetTleParameters() *TleParameters {
	if o == nil {
		return nil
	}
	return o.TleParameters
}

func (o *OrbitMeanElements) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrbitMeanElements) UnmarshalJSON(data []byte) error {
	type unmarshaler OrbitMeanElements
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrbitMeanElements(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrbitMeanElements) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrbitMeanElementsMetadata struct {
	// Creation date/time in UTC
	CreationDate *time.Time `json:"creationDate,omitempty" url:"creationDate,omitempty"`
	// Creating agency or operator
	Originator *string `json:"originator,omitempty" url:"originator,omitempty"`
	// ID that uniquely identifies a message from a given originator.
	MessageID *string `json:"messageId,omitempty" url:"messageId,omitempty"`
	// Reference frame, assumed to be Earth-centered
	RefFrame *OrbitMeanElementsMetadataRefFrame `json:"refFrame,omitempty" url:"refFrame,omitempty"`
	// Reference frame epoch in UTC - mandatory only if not intrinsic to frame definition
	RefFrameEpoch     *time.Time                                  `json:"refFrameEpoch,omitempty" url:"refFrameEpoch,omitempty"`
	MeanElementTheory *OrbitMeanElementsMetadataMeanElementTheory `json:"meanElementTheory,omitempty" url:"meanElementTheory,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrbitMeanElementsMetadata) GetCreationDate() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreationDate
}

func (o *OrbitMeanElementsMetadata) GetOriginator() *string {
	if o == nil {
		return nil
	}
	return o.Originator
}

func (o *OrbitMeanElementsMetadata) GetMessageID() *string {
	if o == nil {
		return nil
	}
	return o.MessageID
}

func (o *OrbitMeanElementsMetadata) GetRefFrame() *OrbitMeanElementsMetadataRefFrame {
	if o == nil {
		return nil
	}
	return o.RefFrame
}

func (o *OrbitMeanElementsMetadata) GetRefFrameEpoch() *time.Time {
	if o == nil {
		return nil
	}
	return o.RefFrameEpoch
}

func (o *OrbitMeanElementsMetadata) GetMeanElementTheory() *OrbitMeanElementsMetadataMeanElementTheory {
	if o == nil {
		return nil
	}
	return o.MeanElementTheory
}

func (o *OrbitMeanElementsMetadata) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrbitMeanElementsMetadata) UnmarshalJSON(data []byte) error {
	type embed OrbitMeanElementsMetadata
	var unmarshaler = struct {
		embed
		CreationDate  *internal.DateTime `json:"creationDate,omitempty"`
		RefFrameEpoch *internal.DateTime `json:"refFrameEpoch,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OrbitMeanElementsMetadata(unmarshaler.embed)
	o.CreationDate = unmarshaler.CreationDate.TimePtr()
	o.RefFrameEpoch = unmarshaler.RefFrameEpoch.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrbitMeanElementsMetadata) MarshalJSON() ([]byte, error) {
	type embed OrbitMeanElementsMetadata
	var marshaler = struct {
		embed
		CreationDate  *internal.DateTime `json:"creationDate,omitempty"`
		RefFrameEpoch *internal.DateTime `json:"refFrameEpoch,omitempty"`
	}{
		embed:         embed(*o),
		CreationDate:  internal.NewOptionalDateTime(o.CreationDate),
		RefFrameEpoch: internal.NewOptionalDateTime(o.RefFrameEpoch),
	}
	return json.Marshal(marshaler)
}

func (o *OrbitMeanElementsMetadata) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrbitMeanElementsMetadataMeanElementTheory string

const (
	OrbitMeanElementsMetadataMeanElementTheoryMeanElementTheoryInvalid OrbitMeanElementsMetadataMeanElementTheory = "MEAN_ELEMENT_THEORY_INVALID"
	OrbitMeanElementsMetadataMeanElementTheoryMeanElementTheorySgp4    OrbitMeanElementsMetadataMeanElementTheory = "MEAN_ELEMENT_THEORY_SGP4"
)

func NewOrbitMeanElementsMetadataMeanElementTheoryFromString(s string) (OrbitMeanElementsMetadataMeanElementTheory, error) {
	switch s {
	case "MEAN_ELEMENT_THEORY_INVALID":
		return OrbitMeanElementsMetadataMeanElementTheoryMeanElementTheoryInvalid, nil
	case "MEAN_ELEMENT_THEORY_SGP4":
		return OrbitMeanElementsMetadataMeanElementTheoryMeanElementTheorySgp4, nil
	}
	var t OrbitMeanElementsMetadataMeanElementTheory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrbitMeanElementsMetadataMeanElementTheory) Ptr() *OrbitMeanElementsMetadataMeanElementTheory {
	return &o
}

// Reference frame, assumed to be Earth-centered
type OrbitMeanElementsMetadataRefFrame string

const (
	OrbitMeanElementsMetadataRefFrameEciReferenceFrameInvalid OrbitMeanElementsMetadataRefFrame = "ECI_REFERENCE_FRAME_INVALID"
	OrbitMeanElementsMetadataRefFrameEciReferenceFrameTeme    OrbitMeanElementsMetadataRefFrame = "ECI_REFERENCE_FRAME_TEME"
)

func NewOrbitMeanElementsMetadataRefFrameFromString(s string) (OrbitMeanElementsMetadataRefFrame, error) {
	switch s {
	case "ECI_REFERENCE_FRAME_INVALID":
		return OrbitMeanElementsMetadataRefFrameEciReferenceFrameInvalid, nil
	case "ECI_REFERENCE_FRAME_TEME":
		return OrbitMeanElementsMetadataRefFrameEciReferenceFrameTeme, nil
	}
	var t OrbitMeanElementsMetadataRefFrame
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrbitMeanElementsMetadataRefFrame) Ptr() *OrbitMeanElementsMetadataRefFrame {
	return &o
}

// Details about an override. Last write wins.
type Override struct {
	// override request id for an override request
	RequestID *string `json:"requestId,omitempty" url:"requestId,omitempty"`
	// proto field path which is the string representation of a field.
	//
	//	example: correlated.primary_entity_id would be primary_entity_id in correlated component
	FieldPath *string `json:"fieldPath,omitempty" url:"fieldPath,omitempty"`
	// new field value corresponding to field path. In the shape of an empty entity with only the changed value.
	//
	//	example: entity: { mil_view: { disposition: Disposition_DISPOSITION_HOSTILE } }
	MaskedFieldValue *Entity `json:"maskedFieldValue,omitempty" url:"maskedFieldValue,omitempty"`
	// status of the override
	Status     *OverrideStatus `json:"status,omitempty" url:"status,omitempty"`
	Provenance *Provenance     `json:"provenance,omitempty" url:"provenance,omitempty"`
	// The type of the override, defined by the stage of the entity lifecycle that the entity was in when the override
	//
	//	was requested.
	Type *OverrideType `json:"type,omitempty" url:"type,omitempty"`
	// Timestamp of the override request. The timestamp is generated by the Entity Manager instance that receives the request.
	RequestTimestamp *time.Time `json:"requestTimestamp,omitempty" url:"requestTimestamp,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Override) GetRequestID() *string {
	if o == nil {
		return nil
	}
	return o.RequestID
}

func (o *Override) GetFieldPath() *string {
	if o == nil {
		return nil
	}
	return o.FieldPath
}

func (o *Override) GetMaskedFieldValue() *Entity {
	if o == nil {
		return nil
	}
	return o.MaskedFieldValue
}

func (o *Override) GetStatus() *OverrideStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *Override) GetProvenance() *Provenance {
	if o == nil {
		return nil
	}
	return o.Provenance
}

func (o *Override) GetType() *OverrideType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Override) GetRequestTimestamp() *time.Time {
	if o == nil {
		return nil
	}
	return o.RequestTimestamp
}

func (o *Override) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Override) UnmarshalJSON(data []byte) error {
	type embed Override
	var unmarshaler = struct {
		embed
		RequestTimestamp *internal.DateTime `json:"requestTimestamp,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Override(unmarshaler.embed)
	o.RequestTimestamp = unmarshaler.RequestTimestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Override) MarshalJSON() ([]byte, error) {
	type embed Override
	var marshaler = struct {
		embed
		RequestTimestamp *internal.DateTime `json:"requestTimestamp,omitempty"`
	}{
		embed:            embed(*o),
		RequestTimestamp: internal.NewOptionalDateTime(o.RequestTimestamp),
	}
	return json.Marshal(marshaler)
}

func (o *Override) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// status of the override
type OverrideStatus string

const (
	OverrideStatusOverrideStatusInvalid         OverrideStatus = "OVERRIDE_STATUS_INVALID"
	OverrideStatusOverrideStatusApplied         OverrideStatus = "OVERRIDE_STATUS_APPLIED"
	OverrideStatusOverrideStatusPending         OverrideStatus = "OVERRIDE_STATUS_PENDING"
	OverrideStatusOverrideStatusTimeout         OverrideStatus = "OVERRIDE_STATUS_TIMEOUT"
	OverrideStatusOverrideStatusRejected        OverrideStatus = "OVERRIDE_STATUS_REJECTED"
	OverrideStatusOverrideStatusDeletionPending OverrideStatus = "OVERRIDE_STATUS_DELETION_PENDING"
)

func NewOverrideStatusFromString(s string) (OverrideStatus, error) {
	switch s {
	case "OVERRIDE_STATUS_INVALID":
		return OverrideStatusOverrideStatusInvalid, nil
	case "OVERRIDE_STATUS_APPLIED":
		return OverrideStatusOverrideStatusApplied, nil
	case "OVERRIDE_STATUS_PENDING":
		return OverrideStatusOverrideStatusPending, nil
	case "OVERRIDE_STATUS_TIMEOUT":
		return OverrideStatusOverrideStatusTimeout, nil
	case "OVERRIDE_STATUS_REJECTED":
		return OverrideStatusOverrideStatusRejected, nil
	case "OVERRIDE_STATUS_DELETION_PENDING":
		return OverrideStatusOverrideStatusDeletionPending, nil
	}
	var t OverrideStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OverrideStatus) Ptr() *OverrideStatus {
	return &o
}

// The type of the override, defined by the stage of the entity lifecycle that the entity was in when the override
//
//	was requested.
type OverrideType string

const (
	OverrideTypeOverrideTypeInvalid    OverrideType = "OVERRIDE_TYPE_INVALID"
	OverrideTypeOverrideTypeLive       OverrideType = "OVERRIDE_TYPE_LIVE"
	OverrideTypeOverrideTypePostExpiry OverrideType = "OVERRIDE_TYPE_POST_EXPIRY"
)

func NewOverrideTypeFromString(s string) (OverrideType, error) {
	switch s {
	case "OVERRIDE_TYPE_INVALID":
		return OverrideTypeOverrideTypeInvalid, nil
	case "OVERRIDE_TYPE_LIVE":
		return OverrideTypeOverrideTypeLive, nil
	case "OVERRIDE_TYPE_POST_EXPIRY":
		return OverrideTypeOverrideTypePostExpiry, nil
	}
	var t OverrideType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OverrideType) Ptr() *OverrideType {
	return &o
}

// Metadata about entity overrides present.
type Overrides struct {
	Override []*Override `json:"override,omitempty" url:"override,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Overrides) GetOverride() []*Override {
	if o == nil {
		return nil
	}
	return o.Override
}

func (o *Overrides) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Overrides) UnmarshalJSON(data []byte) error {
	type unmarshaler Overrides
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Overrides(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Overrides) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Individual payload configuration.
type Payload struct {
	Config *PayloadConfiguration `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Payload) GetConfig() *PayloadConfiguration {
	if p == nil {
		return nil
	}
	return p.Config
}

func (p *Payload) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Payload) UnmarshalJSON(data []byte) error {
	type unmarshaler Payload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Payload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Payload) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayloadConfiguration struct {
	// Identifying ID for the capability.
	//
	//	This ID may be used multiple times to represent payloads that are the same capability but have different operational states
	CapabilityID *string `json:"capabilityId,omitempty" url:"capabilityId,omitempty"`
	// The number of payloads currently available in the configuration.
	Quantity *int `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The target environments the configuration is effective against.
	EffectiveEnvironment []PayloadConfigurationEffectiveEnvironmentItem `json:"effectiveEnvironment,omitempty" url:"effectiveEnvironment,omitempty"`
	// The operational state of this payload.
	PayloadOperationalState *PayloadConfigurationPayloadOperationalState `json:"payloadOperationalState,omitempty" url:"payloadOperationalState,omitempty"`
	// A human readable description of the payload
	PayloadDescription *string `json:"payloadDescription,omitempty" url:"payloadDescription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayloadConfiguration) GetCapabilityID() *string {
	if p == nil {
		return nil
	}
	return p.CapabilityID
}

func (p *PayloadConfiguration) GetQuantity() *int {
	if p == nil {
		return nil
	}
	return p.Quantity
}

func (p *PayloadConfiguration) GetEffectiveEnvironment() []PayloadConfigurationEffectiveEnvironmentItem {
	if p == nil {
		return nil
	}
	return p.EffectiveEnvironment
}

func (p *PayloadConfiguration) GetPayloadOperationalState() *PayloadConfigurationPayloadOperationalState {
	if p == nil {
		return nil
	}
	return p.PayloadOperationalState
}

func (p *PayloadConfiguration) GetPayloadDescription() *string {
	if p == nil {
		return nil
	}
	return p.PayloadDescription
}

func (p *PayloadConfiguration) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayloadConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler PayloadConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayloadConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayloadConfiguration) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayloadConfigurationEffectiveEnvironmentItem string

const (
	PayloadConfigurationEffectiveEnvironmentItemEnvironmentUnknown    PayloadConfigurationEffectiveEnvironmentItem = "ENVIRONMENT_UNKNOWN"
	PayloadConfigurationEffectiveEnvironmentItemEnvironmentAir        PayloadConfigurationEffectiveEnvironmentItem = "ENVIRONMENT_AIR"
	PayloadConfigurationEffectiveEnvironmentItemEnvironmentSurface    PayloadConfigurationEffectiveEnvironmentItem = "ENVIRONMENT_SURFACE"
	PayloadConfigurationEffectiveEnvironmentItemEnvironmentSubSurface PayloadConfigurationEffectiveEnvironmentItem = "ENVIRONMENT_SUB_SURFACE"
	PayloadConfigurationEffectiveEnvironmentItemEnvironmentLand       PayloadConfigurationEffectiveEnvironmentItem = "ENVIRONMENT_LAND"
	PayloadConfigurationEffectiveEnvironmentItemEnvironmentSpace      PayloadConfigurationEffectiveEnvironmentItem = "ENVIRONMENT_SPACE"
)

func NewPayloadConfigurationEffectiveEnvironmentItemFromString(s string) (PayloadConfigurationEffectiveEnvironmentItem, error) {
	switch s {
	case "ENVIRONMENT_UNKNOWN":
		return PayloadConfigurationEffectiveEnvironmentItemEnvironmentUnknown, nil
	case "ENVIRONMENT_AIR":
		return PayloadConfigurationEffectiveEnvironmentItemEnvironmentAir, nil
	case "ENVIRONMENT_SURFACE":
		return PayloadConfigurationEffectiveEnvironmentItemEnvironmentSurface, nil
	case "ENVIRONMENT_SUB_SURFACE":
		return PayloadConfigurationEffectiveEnvironmentItemEnvironmentSubSurface, nil
	case "ENVIRONMENT_LAND":
		return PayloadConfigurationEffectiveEnvironmentItemEnvironmentLand, nil
	case "ENVIRONMENT_SPACE":
		return PayloadConfigurationEffectiveEnvironmentItemEnvironmentSpace, nil
	}
	var t PayloadConfigurationEffectiveEnvironmentItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayloadConfigurationEffectiveEnvironmentItem) Ptr() *PayloadConfigurationEffectiveEnvironmentItem {
	return &p
}

// The operational state of this payload.
type PayloadConfigurationPayloadOperationalState string

const (
	PayloadConfigurationPayloadOperationalStatePayloadOperationalStateInvalid        PayloadConfigurationPayloadOperationalState = "PAYLOAD_OPERATIONAL_STATE_INVALID"
	PayloadConfigurationPayloadOperationalStatePayloadOperationalStateOff            PayloadConfigurationPayloadOperationalState = "PAYLOAD_OPERATIONAL_STATE_OFF"
	PayloadConfigurationPayloadOperationalStatePayloadOperationalStateNonOperational PayloadConfigurationPayloadOperationalState = "PAYLOAD_OPERATIONAL_STATE_NON_OPERATIONAL"
	PayloadConfigurationPayloadOperationalStatePayloadOperationalStateDegraded       PayloadConfigurationPayloadOperationalState = "PAYLOAD_OPERATIONAL_STATE_DEGRADED"
	PayloadConfigurationPayloadOperationalStatePayloadOperationalStateOperational    PayloadConfigurationPayloadOperationalState = "PAYLOAD_OPERATIONAL_STATE_OPERATIONAL"
	PayloadConfigurationPayloadOperationalStatePayloadOperationalStateOutOfService   PayloadConfigurationPayloadOperationalState = "PAYLOAD_OPERATIONAL_STATE_OUT_OF_SERVICE"
	PayloadConfigurationPayloadOperationalStatePayloadOperationalStateUnknown        PayloadConfigurationPayloadOperationalState = "PAYLOAD_OPERATIONAL_STATE_UNKNOWN"
)

func NewPayloadConfigurationPayloadOperationalStateFromString(s string) (PayloadConfigurationPayloadOperationalState, error) {
	switch s {
	case "PAYLOAD_OPERATIONAL_STATE_INVALID":
		return PayloadConfigurationPayloadOperationalStatePayloadOperationalStateInvalid, nil
	case "PAYLOAD_OPERATIONAL_STATE_OFF":
		return PayloadConfigurationPayloadOperationalStatePayloadOperationalStateOff, nil
	case "PAYLOAD_OPERATIONAL_STATE_NON_OPERATIONAL":
		return PayloadConfigurationPayloadOperationalStatePayloadOperationalStateNonOperational, nil
	case "PAYLOAD_OPERATIONAL_STATE_DEGRADED":
		return PayloadConfigurationPayloadOperationalStatePayloadOperationalStateDegraded, nil
	case "PAYLOAD_OPERATIONAL_STATE_OPERATIONAL":
		return PayloadConfigurationPayloadOperationalStatePayloadOperationalStateOperational, nil
	case "PAYLOAD_OPERATIONAL_STATE_OUT_OF_SERVICE":
		return PayloadConfigurationPayloadOperationalStatePayloadOperationalStateOutOfService, nil
	case "PAYLOAD_OPERATIONAL_STATE_UNKNOWN":
		return PayloadConfigurationPayloadOperationalStatePayloadOperationalStateUnknown, nil
	}
	var t PayloadConfigurationPayloadOperationalState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayloadConfigurationPayloadOperationalState) Ptr() *PayloadConfigurationPayloadOperationalState {
	return &p
}

// List of payloads available for an entity.
type Payloads struct {
	PayloadConfigurations []*Payload `json:"payloadConfigurations,omitempty" url:"payloadConfigurations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Payloads) GetPayloadConfigurations() []*Payload {
	if p == nil {
		return nil
	}
	return p.PayloadConfigurations
}

func (p *Payloads) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Payloads) UnmarshalJSON(data []byte) error {
	type unmarshaler Payloads
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Payloads(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Payloads) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Pose struct {
	// Geospatial location defined by this Pose.
	Pos *Lla `json:"pos,omitempty" url:"pos,omitempty"`
	// The quaternion to transform a point in the Pose frame to the ENU frame. The Pose frame could be Body, Turret,
	//
	//	etc and is determined by the context in which this Pose is used.
	//	The normal convention for defining orientation is to list the frames of transformation, for example
	//	att_gimbal_to_enu is the quaternion which transforms a point in the gimbal frame to the body frame, but
	//	in this case we truncate to att_enu because the Pose frame isn't defined. A potentially better name for this
	//	field would have been att_pose_to_enu.
	//
	//	Implementations of this quaternion should left multiply this quaternion to transform a point from the Pose frame
	//	to the enu frame.
	//
	//	Point<Pose\> posePt{1,0,0};
	//	Rotation<Enu, Pose\> attPoseToEnu{};
	//	Point<Enu\> = attPoseToEnu*posePt;
	//
	//	This transformed point represents some vector in ENU space that is aligned with the x axis of the attPoseToEnu
	//	matrix.
	//
	//	An alternative matrix expression is as follows:
	//	ptEnu = M x ptPose
	AttEnu *Quaternion `json:"attEnu,omitempty" url:"attEnu,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Pose) GetPos() *Lla {
	if p == nil {
		return nil
	}
	return p.Pos
}

func (p *Pose) GetAttEnu() *Quaternion {
	if p == nil {
		return nil
	}
	return p.AttEnu
}

func (p *Pose) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Pose) UnmarshalJSON(data []byte) error {
	type unmarshaler Pose
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Pose(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Pose) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// WGS84 position. Position includes four altitude references.
//
//	The data model does not currently support Mean Sea Level (MSL) references,
//	such as the Earth Gravitational Model 1996 (EGM-96) and the Earth Gravitational Model 2008 (EGM-08).
//	If the only altitude reference available to your integration is MSL, convert it to
//	Height Above Ellipsoid (HAE) and populate the altitude_hae_meters field.
type Position struct {
	// WGS84 geodetic latitude in decimal degrees.
	LatitudeDegrees *float64 `json:"latitudeDegrees,omitempty" url:"latitudeDegrees,omitempty"`
	// WGS84 longitude in decimal degrees.
	LongitudeDegrees *float64 `json:"longitudeDegrees,omitempty" url:"longitudeDegrees,omitempty"`
	// altitude as height above ellipsoid (WGS84) in meters. DoubleValue wrapper is used to distinguish optional from
	//
	//	default 0.
	AltitudeHaeMeters *float64 `json:"altitudeHaeMeters,omitempty" url:"altitudeHaeMeters,omitempty"`
	// Altitude as AGL (Above Ground Level) if the upstream data source has this value set. This value represents the
	//
	//	entity's height above the terrain. This is typically measured with a radar altimeter or by using a terrain tile
	//	set lookup. If the value is not set from the upstream, this value is not set.
	AltitudeAglMeters *float64 `json:"altitudeAglMeters,omitempty" url:"altitudeAglMeters,omitempty"`
	// Altitude as ASF (Above Sea Floor) if the upstream data source has this value set. If the value is not set from the upstream, this value is
	//
	//	not set.
	AltitudeAsfMeters *float64 `json:"altitudeAsfMeters,omitempty" url:"altitudeAsfMeters,omitempty"`
	// The depth of the entity from the surface of the water through sensor measurements based on differential pressure
	//
	//	between the interior and exterior of the vessel. If the value is not set from the upstream, this value is not set.
	PressureDepthMeters *float64 `json:"pressureDepthMeters,omitempty" url:"pressureDepthMeters,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Position) GetLatitudeDegrees() *float64 {
	if p == nil {
		return nil
	}
	return p.LatitudeDegrees
}

func (p *Position) GetLongitudeDegrees() *float64 {
	if p == nil {
		return nil
	}
	return p.LongitudeDegrees
}

func (p *Position) GetAltitudeHaeMeters() *float64 {
	if p == nil {
		return nil
	}
	return p.AltitudeHaeMeters
}

func (p *Position) GetAltitudeAglMeters() *float64 {
	if p == nil {
		return nil
	}
	return p.AltitudeAglMeters
}

func (p *Position) GetAltitudeAsfMeters() *float64 {
	if p == nil {
		return nil
	}
	return p.AltitudeAsfMeters
}

func (p *Position) GetPressureDepthMeters() *float64 {
	if p == nil {
		return nil
	}
	return p.PressureDepthMeters
}

func (p *Position) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Position) UnmarshalJSON(data []byte) error {
	type unmarshaler Position
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Position(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Position) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the power level of a system.
type PowerLevel struct {
	// Total power capacity of the system.
	Capacity *float64 `json:"capacity,omitempty" url:"capacity,omitempty"`
	// Remaining power capacity of the system.
	Remaining *float64 `json:"remaining,omitempty" url:"remaining,omitempty"`
	// Percent of power remaining.
	PercentRemaining *float64 `json:"percentRemaining,omitempty" url:"percentRemaining,omitempty"`
	// Voltage of the power source subsystem, as reported by the power source. If the source does not report this value
	//
	//	this field will be null.
	Voltage *float64 `json:"voltage,omitempty" url:"voltage,omitempty"`
	// Current in amps of the power source subsystem, as reported by the power source. If the source does not
	//
	//	report this value this field will be null.
	CurrentAmps *float64 `json:"currentAmps,omitempty" url:"currentAmps,omitempty"`
	// Estimated minutes until empty. Calculated with consumption at the moment, as reported by the power source. If the source does not
	//
	//	report this value this field will be null.
	RunTimeToEmptyMins *float64 `json:"runTimeToEmptyMins,omitempty" url:"runTimeToEmptyMins,omitempty"`
	// Fuel consumption rate in liters per second.
	ConsumptionRateLPerS *float64 `json:"consumptionRateLPerS,omitempty" url:"consumptionRateLPerS,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PowerLevel) GetCapacity() *float64 {
	if p == nil {
		return nil
	}
	return p.Capacity
}

func (p *PowerLevel) GetRemaining() *float64 {
	if p == nil {
		return nil
	}
	return p.Remaining
}

func (p *PowerLevel) GetPercentRemaining() *float64 {
	if p == nil {
		return nil
	}
	return p.PercentRemaining
}

func (p *PowerLevel) GetVoltage() *float64 {
	if p == nil {
		return nil
	}
	return p.Voltage
}

func (p *PowerLevel) GetCurrentAmps() *float64 {
	if p == nil {
		return nil
	}
	return p.CurrentAmps
}

func (p *PowerLevel) GetRunTimeToEmptyMins() *float64 {
	if p == nil {
		return nil
	}
	return p.RunTimeToEmptyMins
}

func (p *PowerLevel) GetConsumptionRateLPerS() *float64 {
	if p == nil {
		return nil
	}
	return p.ConsumptionRateLPerS
}

func (p *PowerLevel) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PowerLevel) UnmarshalJSON(data []byte) error {
	type unmarshaler PowerLevel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PowerLevel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PowerLevel) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the state of a single power source that is connected to this entity.
type PowerSource struct {
	// Status of the power source.
	PowerStatus *PowerSourcePowerStatus `json:"powerStatus,omitempty" url:"powerStatus,omitempty"`
	// Used to determine the type of power source.
	PowerType *PowerSourcePowerType `json:"powerType,omitempty" url:"powerType,omitempty"`
	// Power level of the system. If absent, the power level is assumed to be unknown.
	PowerLevel *PowerLevel `json:"powerLevel,omitempty" url:"powerLevel,omitempty"`
	// Set of human-readable messages with status of the power system. Typically this would be used in an error state
	//
	//	to provide additional error information. This can also be used for informational messages.
	Messages []string `json:"messages,omitempty" url:"messages,omitempty"`
	// Whether the power source is offloadable. If the value is missing (as opposed to false) then the entity does not
	//
	//	report whether the power source is offloadable.
	Offloadable *bool `json:"offloadable,omitempty" url:"offloadable,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PowerSource) GetPowerStatus() *PowerSourcePowerStatus {
	if p == nil {
		return nil
	}
	return p.PowerStatus
}

func (p *PowerSource) GetPowerType() *PowerSourcePowerType {
	if p == nil {
		return nil
	}
	return p.PowerType
}

func (p *PowerSource) GetPowerLevel() *PowerLevel {
	if p == nil {
		return nil
	}
	return p.PowerLevel
}

func (p *PowerSource) GetMessages() []string {
	if p == nil {
		return nil
	}
	return p.Messages
}

func (p *PowerSource) GetOffloadable() *bool {
	if p == nil {
		return nil
	}
	return p.Offloadable
}

func (p *PowerSource) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PowerSource) UnmarshalJSON(data []byte) error {
	type unmarshaler PowerSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PowerSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PowerSource) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Status of the power source.
type PowerSourcePowerStatus string

const (
	PowerSourcePowerStatusPowerStatusInvalid    PowerSourcePowerStatus = "POWER_STATUS_INVALID"
	PowerSourcePowerStatusPowerStatusUnknown    PowerSourcePowerStatus = "POWER_STATUS_UNKNOWN"
	PowerSourcePowerStatusPowerStatusNotPresent PowerSourcePowerStatus = "POWER_STATUS_NOT_PRESENT"
	PowerSourcePowerStatusPowerStatusOperating  PowerSourcePowerStatus = "POWER_STATUS_OPERATING"
	PowerSourcePowerStatusPowerStatusDisabled   PowerSourcePowerStatus = "POWER_STATUS_DISABLED"
	PowerSourcePowerStatusPowerStatusError      PowerSourcePowerStatus = "POWER_STATUS_ERROR"
)

func NewPowerSourcePowerStatusFromString(s string) (PowerSourcePowerStatus, error) {
	switch s {
	case "POWER_STATUS_INVALID":
		return PowerSourcePowerStatusPowerStatusInvalid, nil
	case "POWER_STATUS_UNKNOWN":
		return PowerSourcePowerStatusPowerStatusUnknown, nil
	case "POWER_STATUS_NOT_PRESENT":
		return PowerSourcePowerStatusPowerStatusNotPresent, nil
	case "POWER_STATUS_OPERATING":
		return PowerSourcePowerStatusPowerStatusOperating, nil
	case "POWER_STATUS_DISABLED":
		return PowerSourcePowerStatusPowerStatusDisabled, nil
	case "POWER_STATUS_ERROR":
		return PowerSourcePowerStatusPowerStatusError, nil
	}
	var t PowerSourcePowerStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PowerSourcePowerStatus) Ptr() *PowerSourcePowerStatus {
	return &p
}

// Used to determine the type of power source.
type PowerSourcePowerType string

const (
	PowerSourcePowerTypePowerTypeInvalid PowerSourcePowerType = "POWER_TYPE_INVALID"
	PowerSourcePowerTypePowerTypeUnknown PowerSourcePowerType = "POWER_TYPE_UNKNOWN"
	PowerSourcePowerTypePowerTypeGas     PowerSourcePowerType = "POWER_TYPE_GAS"
	PowerSourcePowerTypePowerTypeBattery PowerSourcePowerType = "POWER_TYPE_BATTERY"
)

func NewPowerSourcePowerTypeFromString(s string) (PowerSourcePowerType, error) {
	switch s {
	case "POWER_TYPE_INVALID":
		return PowerSourcePowerTypePowerTypeInvalid, nil
	case "POWER_TYPE_UNKNOWN":
		return PowerSourcePowerTypePowerTypeUnknown, nil
	case "POWER_TYPE_GAS":
		return PowerSourcePowerTypePowerTypeGas, nil
	case "POWER_TYPE_BATTERY":
		return PowerSourcePowerTypePowerTypeBattery, nil
	}
	var t PowerSourcePowerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PowerSourcePowerType) Ptr() *PowerSourcePowerType {
	return &p
}

// Represents the state of power sources connected to this entity.
type PowerState struct {
	// This is a map where the key is a unique id of the power source and the value is additional information about the
	//
	//	power source.
	SourceIDToState map[string]*PowerSource `json:"sourceIdToState,omitempty" url:"sourceIdToState,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PowerState) GetSourceIDToState() map[string]*PowerSource {
	if p == nil {
		return nil
	}
	return p.SourceIDToState
}

func (p *PowerState) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PowerState) UnmarshalJSON(data []byte) error {
	type unmarshaler PowerState
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PowerState(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PowerState) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PrimaryCorrelation struct {
	// The secondary entity IDs part of this correlation.
	SecondaryEntityIDs []string `json:"secondaryEntityIds,omitempty" url:"secondaryEntityIds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PrimaryCorrelation) GetSecondaryEntityIDs() []string {
	if p == nil {
		return nil
	}
	return p.SecondaryEntityIDs
}

func (p *PrimaryCorrelation) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PrimaryCorrelation) UnmarshalJSON(data []byte) error {
	type unmarshaler PrimaryCorrelation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PrimaryCorrelation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PrimaryCorrelation) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PrimaryMembership struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PrimaryMembership) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PrimaryMembership) UnmarshalJSON(data []byte) error {
	type unmarshaler PrimaryMembership
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PrimaryMembership(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PrimaryMembership) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a frustum in which which all four corner points project onto the ground. All points in this message
//
//	are optional, if the projection to the ground fails then they will not be populated.
type ProjectedFrustum struct {
	// Upper left point of the frustum.
	UpperLeft *Position `json:"upperLeft,omitempty" url:"upperLeft,omitempty"`
	// Upper right point of the frustum.
	UpperRight *Position `json:"upperRight,omitempty" url:"upperRight,omitempty"`
	// Bottom right point of the frustum.
	BottomRight *Position `json:"bottomRight,omitempty" url:"bottomRight,omitempty"`
	// Bottom left point of the frustum.
	BottomLeft *Position `json:"bottomLeft,omitempty" url:"bottomLeft,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProjectedFrustum) GetUpperLeft() *Position {
	if p == nil {
		return nil
	}
	return p.UpperLeft
}

func (p *ProjectedFrustum) GetUpperRight() *Position {
	if p == nil {
		return nil
	}
	return p.UpperRight
}

func (p *ProjectedFrustum) GetBottomRight() *Position {
	if p == nil {
		return nil
	}
	return p.BottomRight
}

func (p *ProjectedFrustum) GetBottomLeft() *Position {
	if p == nil {
		return nil
	}
	return p.BottomLeft
}

func (p *ProjectedFrustum) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectedFrustum) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectedFrustum
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectedFrustum(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectedFrustum) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Data provenance.
type Provenance struct {
	// Name of the integration that produced this entity
	IntegrationName *string `json:"integrationName,omitempty" url:"integrationName,omitempty"`
	// Source data type of this entity. Examples: ADSB, Link16, etc.
	DataType *string `json:"dataType,omitempty" url:"dataType,omitempty"`
	// An ID that allows an element from a source to be uniquely identified
	SourceID *string `json:"sourceId,omitempty" url:"sourceId,omitempty"`
	// The time, according to the source system, that the data in the entity was last modified. Generally, this should
	//
	//	be the time that the source-reported time of validity of the data in the entity. This field must be
	//	updated with every change to the entity or else Entity Manager will discard the update.
	SourceUpdateTime *time.Time `json:"sourceUpdateTime,omitempty" url:"sourceUpdateTime,omitempty"`
	// Description of the modification source. In the case of a user this is the email address.
	SourceDescription *string `json:"sourceDescription,omitempty" url:"sourceDescription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Provenance) GetIntegrationName() *string {
	if p == nil {
		return nil
	}
	return p.IntegrationName
}

func (p *Provenance) GetDataType() *string {
	if p == nil {
		return nil
	}
	return p.DataType
}

func (p *Provenance) GetSourceID() *string {
	if p == nil {
		return nil
	}
	return p.SourceID
}

func (p *Provenance) GetSourceUpdateTime() *time.Time {
	if p == nil {
		return nil
	}
	return p.SourceUpdateTime
}

func (p *Provenance) GetSourceDescription() *string {
	if p == nil {
		return nil
	}
	return p.SourceDescription
}

func (p *Provenance) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Provenance) UnmarshalJSON(data []byte) error {
	type embed Provenance
	var unmarshaler = struct {
		embed
		SourceUpdateTime *internal.DateTime `json:"sourceUpdateTime,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Provenance(unmarshaler.embed)
	p.SourceUpdateTime = unmarshaler.SourceUpdateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Provenance) MarshalJSON() ([]byte, error) {
	type embed Provenance
	var marshaler = struct {
		embed
		SourceUpdateTime *internal.DateTime `json:"sourceUpdateTime,omitempty"`
	}{
		embed:            embed(*p),
		SourceUpdateTime: internal.NewOptionalDateTime(p.SourceUpdateTime),
	}
	return json.Marshal(marshaler)
}

func (p *Provenance) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A component that describe the length in time between two pulses
type PulseRepetitionInterval struct {
	PulseRepetitionIntervalS *Measurement `json:"pulseRepetitionIntervalS,omitempty" url:"pulseRepetitionIntervalS,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PulseRepetitionInterval) GetPulseRepetitionIntervalS() *Measurement {
	if p == nil {
		return nil
	}
	return p.PulseRepetitionIntervalS
}

func (p *PulseRepetitionInterval) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PulseRepetitionInterval) UnmarshalJSON(data []byte) error {
	type unmarshaler PulseRepetitionInterval
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PulseRepetitionInterval(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PulseRepetitionInterval) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Quaternion struct {
	// x, y, z are vector portion, w is scalar
	X *float64 `json:"x,omitempty" url:"x,omitempty"`
	Y *float64 `json:"y,omitempty" url:"y,omitempty"`
	Z *float64 `json:"z,omitempty" url:"z,omitempty"`
	W *float64 `json:"w,omitempty" url:"w,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *Quaternion) GetX() *float64 {
	if q == nil {
		return nil
	}
	return q.X
}

func (q *Quaternion) GetY() *float64 {
	if q == nil {
		return nil
	}
	return q.Y
}

func (q *Quaternion) GetZ() *float64 {
	if q == nil {
		return nil
	}
	return q.Z
}

func (q *Quaternion) GetW() *float64 {
	if q == nil {
		return nil
	}
	return q.W
}

func (q *Quaternion) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *Quaternion) UnmarshalJSON(data []byte) error {
	type unmarshaler Quaternion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = Quaternion(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *Quaternion) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// Range rings allow visual assessment of map distance at varying zoom levels.
type RangeRings struct {
	// The minimum range ring distance, specified in meters.
	MinDistanceM *float64 `json:"minDistanceM,omitempty" url:"minDistanceM,omitempty"`
	// The maximum range ring distance, specified in meters.
	MaxDistanceM *float64 `json:"maxDistanceM,omitempty" url:"maxDistanceM,omitempty"`
	// The count of range rings.
	RingCount *int `json:"ringCount,omitempty" url:"ringCount,omitempty"`
	// The color of range rings, specified in hex string.
	RingLineColor *Color `json:"ringLineColor,omitempty" url:"ringLineColor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RangeRings) GetMinDistanceM() *float64 {
	if r == nil {
		return nil
	}
	return r.MinDistanceM
}

func (r *RangeRings) GetMaxDistanceM() *float64 {
	if r == nil {
		return nil
	}
	return r.MaxDistanceM
}

func (r *RangeRings) GetRingCount() *int {
	if r == nil {
		return nil
	}
	return r.RingCount
}

func (r *RangeRings) GetRingLineColor() *Color {
	if r == nil {
		return nil
	}
	return r.RingLineColor
}

func (r *RangeRings) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RangeRings) UnmarshalJSON(data []byte) error {
	type unmarshaler RangeRings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RangeRings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RangeRings) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The relationship component indicates a relationship to another entity.
type Relationship struct {
	// The entity ID to which this entity is related.
	RelatedEntityID *string `json:"relatedEntityId,omitempty" url:"relatedEntityId,omitempty"`
	// A unique identifier for this relationship. Allows removing or updating relationships.
	RelationshipID *string `json:"relationshipId,omitempty" url:"relationshipId,omitempty"`
	// The relationship type
	RelationshipType *RelationshipType `json:"relationshipType,omitempty" url:"relationshipType,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Relationship) GetRelatedEntityID() *string {
	if r == nil {
		return nil
	}
	return r.RelatedEntityID
}

func (r *Relationship) GetRelationshipID() *string {
	if r == nil {
		return nil
	}
	return r.RelationshipID
}

func (r *Relationship) GetRelationshipType() *RelationshipType {
	if r == nil {
		return nil
	}
	return r.RelationshipType
}

func (r *Relationship) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Relationship) UnmarshalJSON(data []byte) error {
	type unmarshaler Relationship
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Relationship(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Relationship) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Determines the type of relationship between this entity and another.
type RelationshipType struct {
	TrackedBy    *TrackedBy    `json:"trackedBy,omitempty" url:"trackedBy,omitempty"`
	GroupChild   *GroupChild   `json:"groupChild,omitempty" url:"groupChild,omitempty"`
	GroupParent  *GroupParent  `json:"groupParent,omitempty" url:"groupParent,omitempty"`
	MergedFrom   *MergedFrom   `json:"mergedFrom,omitempty" url:"mergedFrom,omitempty"`
	ActiveTarget *ActiveTarget `json:"activeTarget,omitempty" url:"activeTarget,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RelationshipType) GetTrackedBy() *TrackedBy {
	if r == nil {
		return nil
	}
	return r.TrackedBy
}

func (r *RelationshipType) GetGroupChild() *GroupChild {
	if r == nil {
		return nil
	}
	return r.GroupChild
}

func (r *RelationshipType) GetGroupParent() *GroupParent {
	if r == nil {
		return nil
	}
	return r.GroupParent
}

func (r *RelationshipType) GetMergedFrom() *MergedFrom {
	if r == nil {
		return nil
	}
	return r.MergedFrom
}

func (r *RelationshipType) GetActiveTarget() *ActiveTarget {
	if r == nil {
		return nil
	}
	return r.ActiveTarget
}

func (r *RelationshipType) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RelationshipType) UnmarshalJSON(data []byte) error {
	type unmarshaler RelationshipType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RelationshipType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RelationshipType) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The relationships between this entity and other entities in the common operational picture.
type Relationships struct {
	Relationships []*Relationship `json:"relationships,omitempty" url:"relationships,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Relationships) GetRelationships() []*Relationship {
	if r == nil {
		return nil
	}
	return r.Relationships
}

func (r *Relationships) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Relationships) UnmarshalJSON(data []byte) error {
	type unmarshaler Relationships
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Relationships(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Relationships) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents RF configurations supported on this sensor.
type RfConfiguration struct {
	// Frequency ranges that are available for this sensor.
	FrequencyRangeHz []*FrequencyRange `json:"frequencyRangeHz,omitempty" url:"frequencyRangeHz,omitempty"`
	// Bandwidth ranges that are available for this sensor.
	BandwidthRangeHz []*BandwidthRange `json:"bandwidthRangeHz,omitempty" url:"bandwidthRangeHz,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RfConfiguration) GetFrequencyRangeHz() []*FrequencyRange {
	if r == nil {
		return nil
	}
	return r.FrequencyRangeHz
}

func (r *RfConfiguration) GetBandwidthRangeHz() []*BandwidthRange {
	if r == nil {
		return nil
	}
	return r.BandwidthRangeHz
}

func (r *RfConfiguration) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RfConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler RfConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RfConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RfConfiguration) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RouteDetails struct {
	// Free form text giving the name of the entity's destination
	DestinationName *string `json:"destinationName,omitempty" url:"destinationName,omitempty"`
	// Estimated time of arrival at destination
	EstimatedArrivalTime *time.Time `json:"estimatedArrivalTime,omitempty" url:"estimatedArrivalTime,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RouteDetails) GetDestinationName() *string {
	if r == nil {
		return nil
	}
	return r.DestinationName
}

func (r *RouteDetails) GetEstimatedArrivalTime() *time.Time {
	if r == nil {
		return nil
	}
	return r.EstimatedArrivalTime
}

func (r *RouteDetails) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RouteDetails) UnmarshalJSON(data []byte) error {
	type embed RouteDetails
	var unmarshaler = struct {
		embed
		EstimatedArrivalTime *internal.DateTime `json:"estimatedArrivalTime,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RouteDetails(unmarshaler.embed)
	r.EstimatedArrivalTime = unmarshaler.EstimatedArrivalTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RouteDetails) MarshalJSON() ([]byte, error) {
	type embed RouteDetails
	var marshaler = struct {
		embed
		EstimatedArrivalTime *internal.DateTime `json:"estimatedArrivalTime,omitempty"`
	}{
		embed:                embed(*r),
		EstimatedArrivalTime: internal.NewOptionalDateTime(r.EstimatedArrivalTime),
	}
	return json.Marshal(marshaler)
}

func (r *RouteDetails) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A component that describes the scanning characteristics of a signal
type ScanCharacteristics struct {
	ScanType    *ScanCharacteristicsScanType `json:"scanType,omitempty" url:"scanType,omitempty"`
	ScanPeriodS *float64                     `json:"scanPeriodS,omitempty" url:"scanPeriodS,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScanCharacteristics) GetScanType() *ScanCharacteristicsScanType {
	if s == nil {
		return nil
	}
	return s.ScanType
}

func (s *ScanCharacteristics) GetScanPeriodS() *float64 {
	if s == nil {
		return nil
	}
	return s.ScanPeriodS
}

func (s *ScanCharacteristics) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScanCharacteristics) UnmarshalJSON(data []byte) error {
	type unmarshaler ScanCharacteristics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScanCharacteristics(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScanCharacteristics) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScanCharacteristicsScanType string

const (
	ScanCharacteristicsScanTypeScanTypeInvalid                        ScanCharacteristicsScanType = "SCAN_TYPE_INVALID"
	ScanCharacteristicsScanTypeScanTypeCircular                       ScanCharacteristicsScanType = "SCAN_TYPE_CIRCULAR"
	ScanCharacteristicsScanTypeScanTypeBidirectionalHorizontalSector  ScanCharacteristicsScanType = "SCAN_TYPE_BIDIRECTIONAL_HORIZONTAL_SECTOR"
	ScanCharacteristicsScanTypeScanTypeBidirectionalVerticalSector    ScanCharacteristicsScanType = "SCAN_TYPE_BIDIRECTIONAL_VERTICAL_SECTOR"
	ScanCharacteristicsScanTypeScanTypeNonScanning                    ScanCharacteristicsScanType = "SCAN_TYPE_NON_SCANNING"
	ScanCharacteristicsScanTypeScanTypeIrregular                      ScanCharacteristicsScanType = "SCAN_TYPE_IRREGULAR"
	ScanCharacteristicsScanTypeScanTypeConical                        ScanCharacteristicsScanType = "SCAN_TYPE_CONICAL"
	ScanCharacteristicsScanTypeScanTypeLobeSwitching                  ScanCharacteristicsScanType = "SCAN_TYPE_LOBE_SWITCHING"
	ScanCharacteristicsScanTypeScanTypeRaster                         ScanCharacteristicsScanType = "SCAN_TYPE_RASTER"
	ScanCharacteristicsScanTypeScanTypeCircularVerticalSector         ScanCharacteristicsScanType = "SCAN_TYPE_CIRCULAR_VERTICAL_SECTOR"
	ScanCharacteristicsScanTypeScanTypeCircularConical                ScanCharacteristicsScanType = "SCAN_TYPE_CIRCULAR_CONICAL"
	ScanCharacteristicsScanTypeScanTypeSectorConical                  ScanCharacteristicsScanType = "SCAN_TYPE_SECTOR_CONICAL"
	ScanCharacteristicsScanTypeScanTypeAgileBeam                      ScanCharacteristicsScanType = "SCAN_TYPE_AGILE_BEAM"
	ScanCharacteristicsScanTypeScanTypeUnidirectionalVerticalSector   ScanCharacteristicsScanType = "SCAN_TYPE_UNIDIRECTIONAL_VERTICAL_SECTOR"
	ScanCharacteristicsScanTypeScanTypeUnidirectionalHorizontalSector ScanCharacteristicsScanType = "SCAN_TYPE_UNIDIRECTIONAL_HORIZONTAL_SECTOR"
	ScanCharacteristicsScanTypeScanTypeUnidirectionalSector           ScanCharacteristicsScanType = "SCAN_TYPE_UNIDIRECTIONAL_SECTOR"
	ScanCharacteristicsScanTypeScanTypeBidirectionalSector            ScanCharacteristicsScanType = "SCAN_TYPE_BIDIRECTIONAL_SECTOR"
)

func NewScanCharacteristicsScanTypeFromString(s string) (ScanCharacteristicsScanType, error) {
	switch s {
	case "SCAN_TYPE_INVALID":
		return ScanCharacteristicsScanTypeScanTypeInvalid, nil
	case "SCAN_TYPE_CIRCULAR":
		return ScanCharacteristicsScanTypeScanTypeCircular, nil
	case "SCAN_TYPE_BIDIRECTIONAL_HORIZONTAL_SECTOR":
		return ScanCharacteristicsScanTypeScanTypeBidirectionalHorizontalSector, nil
	case "SCAN_TYPE_BIDIRECTIONAL_VERTICAL_SECTOR":
		return ScanCharacteristicsScanTypeScanTypeBidirectionalVerticalSector, nil
	case "SCAN_TYPE_NON_SCANNING":
		return ScanCharacteristicsScanTypeScanTypeNonScanning, nil
	case "SCAN_TYPE_IRREGULAR":
		return ScanCharacteristicsScanTypeScanTypeIrregular, nil
	case "SCAN_TYPE_CONICAL":
		return ScanCharacteristicsScanTypeScanTypeConical, nil
	case "SCAN_TYPE_LOBE_SWITCHING":
		return ScanCharacteristicsScanTypeScanTypeLobeSwitching, nil
	case "SCAN_TYPE_RASTER":
		return ScanCharacteristicsScanTypeScanTypeRaster, nil
	case "SCAN_TYPE_CIRCULAR_VERTICAL_SECTOR":
		return ScanCharacteristicsScanTypeScanTypeCircularVerticalSector, nil
	case "SCAN_TYPE_CIRCULAR_CONICAL":
		return ScanCharacteristicsScanTypeScanTypeCircularConical, nil
	case "SCAN_TYPE_SECTOR_CONICAL":
		return ScanCharacteristicsScanTypeScanTypeSectorConical, nil
	case "SCAN_TYPE_AGILE_BEAM":
		return ScanCharacteristicsScanTypeScanTypeAgileBeam, nil
	case "SCAN_TYPE_UNIDIRECTIONAL_VERTICAL_SECTOR":
		return ScanCharacteristicsScanTypeScanTypeUnidirectionalVerticalSector, nil
	case "SCAN_TYPE_UNIDIRECTIONAL_HORIZONTAL_SECTOR":
		return ScanCharacteristicsScanTypeScanTypeUnidirectionalHorizontalSector, nil
	case "SCAN_TYPE_UNIDIRECTIONAL_SECTOR":
		return ScanCharacteristicsScanTypeScanTypeUnidirectionalSector, nil
	case "SCAN_TYPE_BIDIRECTIONAL_SECTOR":
		return ScanCharacteristicsScanTypeScanTypeBidirectionalSector, nil
	}
	var t ScanCharacteristicsScanType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScanCharacteristicsScanType) Ptr() *ScanCharacteristicsScanType {
	return &s
}

// A Schedule associated with this entity
type Schedule struct {
	// expression that represents this schedule's "ON" state
	Windows []*CronWindow `json:"windows,omitempty" url:"windows,omitempty"`
	// A unique identifier for this schedule.
	ScheduleID *string `json:"scheduleId,omitempty" url:"scheduleId,omitempty"`
	// The schedule type
	ScheduleType *ScheduleScheduleType `json:"scheduleType,omitempty" url:"scheduleType,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Schedule) GetWindows() []*CronWindow {
	if s == nil {
		return nil
	}
	return s.Windows
}

func (s *Schedule) GetScheduleID() *string {
	if s == nil {
		return nil
	}
	return s.ScheduleID
}

func (s *Schedule) GetScheduleType() *ScheduleScheduleType {
	if s == nil {
		return nil
	}
	return s.ScheduleType
}

func (s *Schedule) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Schedule) UnmarshalJSON(data []byte) error {
	type unmarshaler Schedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Schedule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Schedule) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The schedule type
type ScheduleScheduleType string

const (
	ScheduleScheduleTypeScheduleTypeInvalid         ScheduleScheduleType = "SCHEDULE_TYPE_INVALID"
	ScheduleScheduleTypeScheduleTypeZoneEnabled     ScheduleScheduleType = "SCHEDULE_TYPE_ZONE_ENABLED"
	ScheduleScheduleTypeScheduleTypeZoneTempEnabled ScheduleScheduleType = "SCHEDULE_TYPE_ZONE_TEMP_ENABLED"
)

func NewScheduleScheduleTypeFromString(s string) (ScheduleScheduleType, error) {
	switch s {
	case "SCHEDULE_TYPE_INVALID":
		return ScheduleScheduleTypeScheduleTypeInvalid, nil
	case "SCHEDULE_TYPE_ZONE_ENABLED":
		return ScheduleScheduleTypeScheduleTypeZoneEnabled, nil
	case "SCHEDULE_TYPE_ZONE_TEMP_ENABLED":
		return ScheduleScheduleTypeScheduleTypeZoneTempEnabled, nil
	}
	var t ScheduleScheduleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScheduleScheduleType) Ptr() *ScheduleScheduleType {
	return &s
}

// Schedules associated with this entity
type Schedules struct {
	Schedules []*Schedule `json:"schedules,omitempty" url:"schedules,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Schedules) GetSchedules() []*Schedule {
	if s == nil {
		return nil
	}
	return s.Schedules
}

func (s *Schedules) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Schedules) UnmarshalJSON(data []byte) error {
	type unmarshaler Schedules
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Schedules(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Schedules) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SecondaryCorrelation struct {
	// The primary of this correlation.
	PrimaryEntityID *string `json:"primaryEntityId,omitempty" url:"primaryEntityId,omitempty"`
	// Metadata about the correlation.
	Metadata *CorrelationMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SecondaryCorrelation) GetPrimaryEntityID() *string {
	if s == nil {
		return nil
	}
	return s.PrimaryEntityID
}

func (s *SecondaryCorrelation) GetMetadata() *CorrelationMetadata {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *SecondaryCorrelation) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecondaryCorrelation) UnmarshalJSON(data []byte) error {
	type unmarshaler SecondaryCorrelation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecondaryCorrelation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecondaryCorrelation) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Individual sensor configuration.
type Sensor struct {
	// This generally is used to indicate a specific type at a more detailed granularity. E.g. COMInt or LWIR
	SensorID         *string                 `json:"sensorId,omitempty" url:"sensorId,omitempty"`
	OperationalState *SensorOperationalState `json:"operationalState,omitempty" url:"operationalState,omitempty"`
	// The type of sensor
	SensorType *SensorSensorType `json:"sensorType,omitempty" url:"sensorType,omitempty"`
	// A human readable description of the sensor
	SensorDescription *string `json:"sensorDescription,omitempty" url:"sensorDescription,omitempty"`
	// RF configuration details of the sensor
	RfConfiguraton *RfConfiguration `json:"rfConfiguraton,omitempty" url:"rfConfiguraton,omitempty"`
	// Time of the latest detection from the sensor
	LastDetectionTimestamp *time.Time `json:"lastDetectionTimestamp,omitempty" url:"lastDetectionTimestamp,omitempty"`
	// Multiple fields of view for a single sensor component
	FieldsOfView []*FieldOfView `json:"fieldsOfView,omitempty" url:"fieldsOfView,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Sensor) GetSensorID() *string {
	if s == nil {
		return nil
	}
	return s.SensorID
}

func (s *Sensor) GetOperationalState() *SensorOperationalState {
	if s == nil {
		return nil
	}
	return s.OperationalState
}

func (s *Sensor) GetSensorType() *SensorSensorType {
	if s == nil {
		return nil
	}
	return s.SensorType
}

func (s *Sensor) GetSensorDescription() *string {
	if s == nil {
		return nil
	}
	return s.SensorDescription
}

func (s *Sensor) GetRfConfiguraton() *RfConfiguration {
	if s == nil {
		return nil
	}
	return s.RfConfiguraton
}

func (s *Sensor) GetLastDetectionTimestamp() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastDetectionTimestamp
}

func (s *Sensor) GetFieldsOfView() []*FieldOfView {
	if s == nil {
		return nil
	}
	return s.FieldsOfView
}

func (s *Sensor) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Sensor) UnmarshalJSON(data []byte) error {
	type embed Sensor
	var unmarshaler = struct {
		embed
		LastDetectionTimestamp *internal.DateTime `json:"lastDetectionTimestamp,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Sensor(unmarshaler.embed)
	s.LastDetectionTimestamp = unmarshaler.LastDetectionTimestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Sensor) MarshalJSON() ([]byte, error) {
	type embed Sensor
	var marshaler = struct {
		embed
		LastDetectionTimestamp *internal.DateTime `json:"lastDetectionTimestamp,omitempty"`
	}{
		embed:                  embed(*s),
		LastDetectionTimestamp: internal.NewOptionalDateTime(s.LastDetectionTimestamp),
	}
	return json.Marshal(marshaler)
}

func (s *Sensor) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SensorOperationalState string

const (
	SensorOperationalStateOperationalStateInvalid        SensorOperationalState = "OPERATIONAL_STATE_INVALID"
	SensorOperationalStateOperationalStateOff            SensorOperationalState = "OPERATIONAL_STATE_OFF"
	SensorOperationalStateOperationalStateNonOperational SensorOperationalState = "OPERATIONAL_STATE_NON_OPERATIONAL"
	SensorOperationalStateOperationalStateDegraded       SensorOperationalState = "OPERATIONAL_STATE_DEGRADED"
	SensorOperationalStateOperationalStateOperational    SensorOperationalState = "OPERATIONAL_STATE_OPERATIONAL"
	SensorOperationalStateOperationalStateDenied         SensorOperationalState = "OPERATIONAL_STATE_DENIED"
)

func NewSensorOperationalStateFromString(s string) (SensorOperationalState, error) {
	switch s {
	case "OPERATIONAL_STATE_INVALID":
		return SensorOperationalStateOperationalStateInvalid, nil
	case "OPERATIONAL_STATE_OFF":
		return SensorOperationalStateOperationalStateOff, nil
	case "OPERATIONAL_STATE_NON_OPERATIONAL":
		return SensorOperationalStateOperationalStateNonOperational, nil
	case "OPERATIONAL_STATE_DEGRADED":
		return SensorOperationalStateOperationalStateDegraded, nil
	case "OPERATIONAL_STATE_OPERATIONAL":
		return SensorOperationalStateOperationalStateOperational, nil
	case "OPERATIONAL_STATE_DENIED":
		return SensorOperationalStateOperationalStateDenied, nil
	}
	var t SensorOperationalState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SensorOperationalState) Ptr() *SensorOperationalState {
	return &s
}

// The type of sensor
type SensorSensorType string

const (
	SensorSensorTypeSensorTypeInvalid     SensorSensorType = "SENSOR_TYPE_INVALID"
	SensorSensorTypeSensorTypeRadar       SensorSensorType = "SENSOR_TYPE_RADAR"
	SensorSensorTypeSensorTypeCamera      SensorSensorType = "SENSOR_TYPE_CAMERA"
	SensorSensorTypeSensorTypeTransponder SensorSensorType = "SENSOR_TYPE_TRANSPONDER"
	SensorSensorTypeSensorTypeRf          SensorSensorType = "SENSOR_TYPE_RF"
	SensorSensorTypeSensorTypeGps         SensorSensorType = "SENSOR_TYPE_GPS"
	SensorSensorTypeSensorTypePtuPos      SensorSensorType = "SENSOR_TYPE_PTU_POS"
	SensorSensorTypeSensorTypePerimeter   SensorSensorType = "SENSOR_TYPE_PERIMETER"
	SensorSensorTypeSensorTypeSonar       SensorSensorType = "SENSOR_TYPE_SONAR"
)

func NewSensorSensorTypeFromString(s string) (SensorSensorType, error) {
	switch s {
	case "SENSOR_TYPE_INVALID":
		return SensorSensorTypeSensorTypeInvalid, nil
	case "SENSOR_TYPE_RADAR":
		return SensorSensorTypeSensorTypeRadar, nil
	case "SENSOR_TYPE_CAMERA":
		return SensorSensorTypeSensorTypeCamera, nil
	case "SENSOR_TYPE_TRANSPONDER":
		return SensorSensorTypeSensorTypeTransponder, nil
	case "SENSOR_TYPE_RF":
		return SensorSensorTypeSensorTypeRf, nil
	case "SENSOR_TYPE_GPS":
		return SensorSensorTypeSensorTypeGps, nil
	case "SENSOR_TYPE_PTU_POS":
		return SensorSensorTypeSensorTypePtuPos, nil
	case "SENSOR_TYPE_PERIMETER":
		return SensorSensorTypeSensorTypePerimeter, nil
	case "SENSOR_TYPE_SONAR":
		return SensorSensorTypeSensorTypeSonar, nil
	}
	var t SensorSensorType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SensorSensorType) Ptr() *SensorSensorType {
	return &s
}

// List of sensors available for an entity.
type Sensors struct {
	Sensors []*Sensor `json:"sensors,omitempty" url:"sensors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Sensors) GetSensors() []*Sensor {
	if s == nil {
		return nil
	}
	return s.Sensors
}

func (s *Sensors) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Sensors) UnmarshalJSON(data []byte) error {
	type unmarshaler Sensors
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Sensors(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Sensors) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A component that describes an entity's signal characteristics.
type Signal struct {
	FrequencyCenter *Frequency      `json:"frequencyCenter,omitempty" url:"frequencyCenter,omitempty"`
	FrequencyRange  *FrequencyRange `json:"frequencyRange,omitempty" url:"frequencyRange,omitempty"`
	// Indicates the bandwidth of a signal (Hz).
	BandwidthHz *float64 `json:"bandwidthHz,omitempty" url:"bandwidthHz,omitempty"`
	// Indicates the signal to noise (SNR) of this signal.
	SignalToNoiseRatio *float64       `json:"signalToNoiseRatio,omitempty" url:"signalToNoiseRatio,omitempty"`
	LineOfBearing      *LineOfBearing `json:"lineOfBearing,omitempty" url:"lineOfBearing,omitempty"`
	Fixed              *Fixed         `json:"fixed,omitempty" url:"fixed,omitempty"`
	// Emitter notations associated with this entity.
	EmitterNotations []*EmitterNotation `json:"emitterNotations,omitempty" url:"emitterNotations,omitempty"`
	// length in time of a single pulse
	PulseWidthS *float64 `json:"pulseWidthS,omitempty" url:"pulseWidthS,omitempty"`
	// length in time between the start of two pulses
	PulseRepetitionInterval *PulseRepetitionInterval `json:"pulseRepetitionInterval,omitempty" url:"pulseRepetitionInterval,omitempty"`
	// describes how a signal is observing the environment
	ScanCharacteristics *ScanCharacteristics `json:"scanCharacteristics,omitempty" url:"scanCharacteristics,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Signal) GetFrequencyCenter() *Frequency {
	if s == nil {
		return nil
	}
	return s.FrequencyCenter
}

func (s *Signal) GetFrequencyRange() *FrequencyRange {
	if s == nil {
		return nil
	}
	return s.FrequencyRange
}

func (s *Signal) GetBandwidthHz() *float64 {
	if s == nil {
		return nil
	}
	return s.BandwidthHz
}

func (s *Signal) GetSignalToNoiseRatio() *float64 {
	if s == nil {
		return nil
	}
	return s.SignalToNoiseRatio
}

func (s *Signal) GetLineOfBearing() *LineOfBearing {
	if s == nil {
		return nil
	}
	return s.LineOfBearing
}

func (s *Signal) GetFixed() *Fixed {
	if s == nil {
		return nil
	}
	return s.Fixed
}

func (s *Signal) GetEmitterNotations() []*EmitterNotation {
	if s == nil {
		return nil
	}
	return s.EmitterNotations
}

func (s *Signal) GetPulseWidthS() *float64 {
	if s == nil {
		return nil
	}
	return s.PulseWidthS
}

func (s *Signal) GetPulseRepetitionInterval() *PulseRepetitionInterval {
	if s == nil {
		return nil
	}
	return s.PulseRepetitionInterval
}

func (s *Signal) GetScanCharacteristics() *ScanCharacteristics {
	if s == nil {
		return nil
	}
	return s.ScanCharacteristics
}

func (s *Signal) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Signal) UnmarshalJSON(data []byte) error {
	type unmarshaler Signal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Signal(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Signal) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type Status struct {
	// The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
	Code *int `json:"code,omitempty" url:"code,omitempty"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// A list of messages that carry the error details.  There is a common set of message types for APIs to use.
	Details []*GoogleProtobufAny `json:"details,omitempty" url:"details,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Status) GetCode() *int {
	if s == nil {
		return nil
	}
	return s.Code
}

func (s *Status) GetMessage() *string {
	if s == nil {
		return nil
	}
	return s.Message
}

func (s *Status) GetDetails() []*GoogleProtobufAny {
	if s == nil {
		return nil
	}
	return s.Details
}

func (s *Status) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Status) UnmarshalJSON(data []byte) error {
	type unmarshaler Status
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Status(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Status) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents the state of supplies associated with an entity (available but not in condition to use immediately)
type Supplies struct {
	Fuel []*Fuel `json:"fuel,omitempty" url:"fuel,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Supplies) GetFuel() []*Fuel {
	if s == nil {
		return nil
	}
	return s.Fuel
}

func (s *Supplies) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Supplies) UnmarshalJSON(data []byte) error {
	type unmarshaler Supplies
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Supplies(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Supplies) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// symmetric 2d matrix only representing the upper right triangle, useful for
//
//	covariance matrices
type TMat2 struct {
	Mxx *float64 `json:"mxx,omitempty" url:"mxx,omitempty"`
	Mxy *float64 `json:"mxy,omitempty" url:"mxy,omitempty"`
	Myy *float64 `json:"myy,omitempty" url:"myy,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TMat2) GetMxx() *float64 {
	if t == nil {
		return nil
	}
	return t.Mxx
}

func (t *TMat2) GetMxy() *float64 {
	if t == nil {
		return nil
	}
	return t.Mxy
}

func (t *TMat2) GetMyy() *float64 {
	if t == nil {
		return nil
	}
	return t.Myy
}

func (t *TMat2) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TMat2) UnmarshalJSON(data []byte) error {
	type unmarshaler TMat2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TMat2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TMat2) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Symmetric 3d matrix only representing the upper right triangle.
type TMat3 struct {
	Mxx *float64 `json:"mxx,omitempty" url:"mxx,omitempty"`
	Mxy *float64 `json:"mxy,omitempty" url:"mxy,omitempty"`
	Mxz *float64 `json:"mxz,omitempty" url:"mxz,omitempty"`
	Myy *float64 `json:"myy,omitempty" url:"myy,omitempty"`
	Myz *float64 `json:"myz,omitempty" url:"myz,omitempty"`
	Mzz *float64 `json:"mzz,omitempty" url:"mzz,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TMat3) GetMxx() *float64 {
	if t == nil {
		return nil
	}
	return t.Mxx
}

func (t *TMat3) GetMxy() *float64 {
	if t == nil {
		return nil
	}
	return t.Mxy
}

func (t *TMat3) GetMxz() *float64 {
	if t == nil {
		return nil
	}
	return t.Mxz
}

func (t *TMat3) GetMyy() *float64 {
	if t == nil {
		return nil
	}
	return t.Myy
}

func (t *TMat3) GetMyz() *float64 {
	if t == nil {
		return nil
	}
	return t.Myz
}

func (t *TMat3) GetMzz() *float64 {
	if t == nil {
		return nil
	}
	return t.Mzz
}

func (t *TMat3) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TMat3) UnmarshalJSON(data []byte) error {
	type unmarshaler TMat3
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TMat3(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TMat3) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The target prioritization associated with an entity.
type TargetPriority struct {
	// Describes the target priority in relation to high value target lists.
	HighValueTarget *HighValueTarget `json:"highValueTarget,omitempty" url:"highValueTarget,omitempty"`
	// Describes whether the entity should be treated as a threat
	Threat *Threat `json:"threat,omitempty" url:"threat,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TargetPriority) GetHighValueTarget() *HighValueTarget {
	if t == nil {
		return nil
	}
	return t.HighValueTarget
}

func (t *TargetPriority) GetThreat() *Threat {
	if t == nil {
		return nil
	}
	return t.Threat
}

func (t *TargetPriority) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TargetPriority) UnmarshalJSON(data []byte) error {
	type unmarshaler TargetPriority
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TargetPriority(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TargetPriority) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Catalog of supported tasks.
type TaskCatalog struct {
	TaskDefinitions []*TaskDefinition `json:"taskDefinitions,omitempty" url:"taskDefinitions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaskCatalog) GetTaskDefinitions() []*TaskDefinition {
	if t == nil {
		return nil
	}
	return t.TaskDefinitions
}

func (t *TaskCatalog) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaskCatalog) UnmarshalJSON(data []byte) error {
	type unmarshaler TaskCatalog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaskCatalog(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaskCatalog) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Defines a supported task by the task specification URL of its "Any" type.
type TaskDefinition struct {
	// Url path must be prefixed with `type.googleapis.com/`.
	TaskSpecificationURL *string `json:"taskSpecificationUrl,omitempty" url:"taskSpecificationUrl,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaskDefinition) GetTaskSpecificationURL() *string {
	if t == nil {
		return nil
	}
	return t.TaskSpecificationURL
}

func (t *TaskDefinition) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaskDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler TaskDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaskDefinition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaskDefinition) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a team of agents
type Team struct {
	// Entity ID of the team
	EntityID *string  `json:"entityId,omitempty" url:"entityId,omitempty"`
	Members  []*Agent `json:"members,omitempty" url:"members,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Team) GetEntityID() *string {
	if t == nil {
		return nil
	}
	return t.EntityID
}

func (t *Team) GetMembers() []*Agent {
	if t == nil {
		return nil
	}
	return t.Members
}

func (t *Team) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Team) UnmarshalJSON(data []byte) error {
	type unmarshaler Team
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Team(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Team) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Describes whether an entity is a threat or not.
type Threat struct {
	// Indicates that the entity has been determined to be a threat.
	IsThreat *bool `json:"isThreat,omitempty" url:"isThreat,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Threat) GetIsThreat() *bool {
	if t == nil {
		return nil
	}
	return t.IsThreat
}

func (t *Threat) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Threat) UnmarshalJSON(data []byte) error {
	type unmarshaler Threat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Threat(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Threat) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The datetime string in ISO 8601 format.
type Timestamp = string

type TleParameters struct {
	// Integer specifying TLE ephemeris type
	EphemerisType *int `json:"ephemerisType,omitempty" url:"ephemerisType,omitempty"`
	// User-defined free-text message classification/caveats of this TLE
	ClassificationType *string `json:"classificationType,omitempty" url:"classificationType,omitempty"`
	// Norad catalog number: integer up to nine digits.
	NoradCatID   *int `json:"noradCatId,omitempty" url:"noradCatId,omitempty"`
	ElementSetNo *int `json:"elementSetNo,omitempty" url:"elementSetNo,omitempty"`
	// Optional: revolution number
	RevAtEpoch *int `json:"revAtEpoch,omitempty" url:"revAtEpoch,omitempty"`
	// Drag parameter for SGP-4 in units 1 / Earth radii
	Bstar *float64 `json:"bstar,omitempty" url:"bstar,omitempty"`
	// Drag parameter for SGP4-XP in units m^2 / kg
	Bterm *float64 `json:"bterm,omitempty" url:"bterm,omitempty"`
	// First time derivative of mean motion in rev / day^2
	MeanMotionDot *float64 `json:"meanMotionDot,omitempty" url:"meanMotionDot,omitempty"`
	// Second time derivative of mean motion in rev / day^3. For use with SGP or PPT3.
	MeanMotionDdot *float64 `json:"meanMotionDdot,omitempty" url:"meanMotionDdot,omitempty"`
	// Solar radiation pressure coefficient A_gamma / m in m^2 / kg. For use with SGP4-XP.
	Agom *float64 `json:"agom,omitempty" url:"agom,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TleParameters) GetEphemerisType() *int {
	if t == nil {
		return nil
	}
	return t.EphemerisType
}

func (t *TleParameters) GetClassificationType() *string {
	if t == nil {
		return nil
	}
	return t.ClassificationType
}

func (t *TleParameters) GetNoradCatID() *int {
	if t == nil {
		return nil
	}
	return t.NoradCatID
}

func (t *TleParameters) GetElementSetNo() *int {
	if t == nil {
		return nil
	}
	return t.ElementSetNo
}

func (t *TleParameters) GetRevAtEpoch() *int {
	if t == nil {
		return nil
	}
	return t.RevAtEpoch
}

func (t *TleParameters) GetBstar() *float64 {
	if t == nil {
		return nil
	}
	return t.Bstar
}

func (t *TleParameters) GetBterm() *float64 {
	if t == nil {
		return nil
	}
	return t.Bterm
}

func (t *TleParameters) GetMeanMotionDot() *float64 {
	if t == nil {
		return nil
	}
	return t.MeanMotionDot
}

func (t *TleParameters) GetMeanMotionDdot() *float64 {
	if t == nil {
		return nil
	}
	return t.MeanMotionDdot
}

func (t *TleParameters) GetAgom() *float64 {
	if t == nil {
		return nil
	}
	return t.Agom
}

func (t *TleParameters) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TleParameters) UnmarshalJSON(data []byte) error {
	type unmarshaler TleParameters
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TleParameters(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TleParameters) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Available for Entities that are tracked.
type Tracked struct {
	// Quality score, 0-15, nil if none
	TrackQualityWrapper *int `json:"trackQualityWrapper,omitempty" url:"trackQualityWrapper,omitempty"`
	// Sensor hits aggregation on the tracked entity.
	SensorHits *int `json:"sensorHits,omitempty" url:"sensorHits,omitempty"`
	// Estimated number of objects or units that are represented by this entity. Known as Strength in certain contexts (Link16)
	//
	//	if UpperBound == LowerBound; (strength = LowerBound)
	//	If both UpperBound and LowerBound are defined; strength is between LowerBound and UpperBound (represented as string "Strength: 4-5")
	//	If UpperBound is defined only (LowerBound unset), Strength ≤ UpperBound
	//	If LowerBound is defined only (UpperBound unset), LowerBound ≤ Strength
	//	0 indicates unset.
	NumberOfObjects *UInt32Range `json:"numberOfObjects,omitempty" url:"numberOfObjects,omitempty"`
	// The radar cross section (RCS) is a measure of how detectable an object is by radar. A large RCS indicates an object is more easily
	//
	//	detected. The unit is “decibels per square meter,” or dBsm
	RadarCrossSection *float64 `json:"radarCrossSection,omitempty" url:"radarCrossSection,omitempty"`
	// Timestamp of the latest tracking measurement for this entity.
	LastMeasurementTime *time.Time `json:"lastMeasurementTime,omitempty" url:"lastMeasurementTime,omitempty"`
	// The relative position of a track with respect to the entity that is tracking it. Used for tracks that do not yet have a 3D position.
	//
	//	For this entity (A), being tracked by some entity (B), this LineOfBearing would express a ray from B to A.
	LineOfBearing *LineOfBearing `json:"lineOfBearing,omitempty" url:"lineOfBearing,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tracked) GetTrackQualityWrapper() *int {
	if t == nil {
		return nil
	}
	return t.TrackQualityWrapper
}

func (t *Tracked) GetSensorHits() *int {
	if t == nil {
		return nil
	}
	return t.SensorHits
}

func (t *Tracked) GetNumberOfObjects() *UInt32Range {
	if t == nil {
		return nil
	}
	return t.NumberOfObjects
}

func (t *Tracked) GetRadarCrossSection() *float64 {
	if t == nil {
		return nil
	}
	return t.RadarCrossSection
}

func (t *Tracked) GetLastMeasurementTime() *time.Time {
	if t == nil {
		return nil
	}
	return t.LastMeasurementTime
}

func (t *Tracked) GetLineOfBearing() *LineOfBearing {
	if t == nil {
		return nil
	}
	return t.LineOfBearing
}

func (t *Tracked) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tracked) UnmarshalJSON(data []byte) error {
	type embed Tracked
	var unmarshaler = struct {
		embed
		LastMeasurementTime *internal.DateTime `json:"lastMeasurementTime,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Tracked(unmarshaler.embed)
	t.LastMeasurementTime = unmarshaler.LastMeasurementTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tracked) MarshalJSON() ([]byte, error) {
	type embed Tracked
	var marshaler = struct {
		embed
		LastMeasurementTime *internal.DateTime `json:"lastMeasurementTime,omitempty"`
	}{
		embed:               embed(*t),
		LastMeasurementTime: internal.NewOptionalDateTime(t.LastMeasurementTime),
	}
	return json.Marshal(marshaler)
}

func (t *Tracked) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Describes the relationship between the entity being tracked ("tracked entity") and the entity that is
//
//	performing the tracking ("tracking entity").
type TrackedBy struct {
	// Sensor details of the tracking entity's sensors that were active and tracking the tracked entity. This may be
	//
	//	a subset of the total sensors available on the tracking entity.
	ActivelyTrackingSensors *Sensors `json:"activelyTrackingSensors,omitempty" url:"activelyTrackingSensors,omitempty"`
	// Latest time that any sensor in actively_tracking_sensors detected the tracked entity.
	LastMeasurementTimestamp *time.Time `json:"lastMeasurementTimestamp,omitempty" url:"lastMeasurementTimestamp,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TrackedBy) GetActivelyTrackingSensors() *Sensors {
	if t == nil {
		return nil
	}
	return t.ActivelyTrackingSensors
}

func (t *TrackedBy) GetLastMeasurementTimestamp() *time.Time {
	if t == nil {
		return nil
	}
	return t.LastMeasurementTimestamp
}

func (t *TrackedBy) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TrackedBy) UnmarshalJSON(data []byte) error {
	type embed TrackedBy
	var unmarshaler = struct {
		embed
		LastMeasurementTimestamp *internal.DateTime `json:"lastMeasurementTimestamp,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TrackedBy(unmarshaler.embed)
	t.LastMeasurementTimestamp = unmarshaler.LastMeasurementTimestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrackedBy) MarshalJSON() ([]byte, error) {
	type embed TrackedBy
	var marshaler = struct {
		embed
		LastMeasurementTimestamp *internal.DateTime `json:"lastMeasurementTimestamp,omitempty"`
	}{
		embed:                    embed(*t),
		LastMeasurementTimestamp: internal.NewOptionalDateTime(t.LastMeasurementTimestamp),
	}
	return json.Marshal(marshaler)
}

func (t *TrackedBy) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// A message describing any transponder codes associated with Mode 1, 2, 3, 4, 5, S interrogations.
type TransponderCodes struct {
	// The mode 1 code assigned to military assets.
	Mode1 *int `json:"mode1,omitempty" url:"mode1,omitempty"`
	// The Mode 2 code assigned to military assets.
	Mode2 *int `json:"mode2,omitempty" url:"mode2,omitempty"`
	// The Mode 3 code assigned by ATC to the asset.
	Mode3 *int `json:"mode3,omitempty" url:"mode3,omitempty"`
	// The validity of the response from the Mode 4 interrogation.
	Mode4InterrogationResponse *TransponderCodesMode4InterrogationResponse `json:"mode4InterrogationResponse,omitempty" url:"mode4InterrogationResponse,omitempty"`
	// The Mode 5 transponder codes.
	Mode5 *Mode5 `json:"mode5,omitempty" url:"mode5,omitempty"`
	// The Mode S transponder codes.
	ModeS *ModeS `json:"modeS,omitempty" url:"modeS,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransponderCodes) GetMode1() *int {
	if t == nil {
		return nil
	}
	return t.Mode1
}

func (t *TransponderCodes) GetMode2() *int {
	if t == nil {
		return nil
	}
	return t.Mode2
}

func (t *TransponderCodes) GetMode3() *int {
	if t == nil {
		return nil
	}
	return t.Mode3
}

func (t *TransponderCodes) GetMode4InterrogationResponse() *TransponderCodesMode4InterrogationResponse {
	if t == nil {
		return nil
	}
	return t.Mode4InterrogationResponse
}

func (t *TransponderCodes) GetMode5() *Mode5 {
	if t == nil {
		return nil
	}
	return t.Mode5
}

func (t *TransponderCodes) GetModeS() *ModeS {
	if t == nil {
		return nil
	}
	return t.ModeS
}

func (t *TransponderCodes) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransponderCodes) UnmarshalJSON(data []byte) error {
	type unmarshaler TransponderCodes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransponderCodes(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransponderCodes) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The validity of the response from the Mode 4 interrogation.
type TransponderCodesMode4InterrogationResponse string

const (
	TransponderCodesMode4InterrogationResponseInterrogationResponseInvalid    TransponderCodesMode4InterrogationResponse = "INTERROGATION_RESPONSE_INVALID"
	TransponderCodesMode4InterrogationResponseInterrogationResponseCorrect    TransponderCodesMode4InterrogationResponse = "INTERROGATION_RESPONSE_CORRECT"
	TransponderCodesMode4InterrogationResponseInterrogationResponseIncorrect  TransponderCodesMode4InterrogationResponse = "INTERROGATION_RESPONSE_INCORRECT"
	TransponderCodesMode4InterrogationResponseInterrogationResponseNoResponse TransponderCodesMode4InterrogationResponse = "INTERROGATION_RESPONSE_NO_RESPONSE"
)

func NewTransponderCodesMode4InterrogationResponseFromString(s string) (TransponderCodesMode4InterrogationResponse, error) {
	switch s {
	case "INTERROGATION_RESPONSE_INVALID":
		return TransponderCodesMode4InterrogationResponseInterrogationResponseInvalid, nil
	case "INTERROGATION_RESPONSE_CORRECT":
		return TransponderCodesMode4InterrogationResponseInterrogationResponseCorrect, nil
	case "INTERROGATION_RESPONSE_INCORRECT":
		return TransponderCodesMode4InterrogationResponseInterrogationResponseIncorrect, nil
	case "INTERROGATION_RESPONSE_NO_RESPONSE":
		return TransponderCodesMode4InterrogationResponseInterrogationResponseNoResponse, nil
	}
	var t TransponderCodesMode4InterrogationResponse
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransponderCodesMode4InterrogationResponse) Ptr() *TransponderCodesMode4InterrogationResponse {
	return &t
}

type UInt32Range struct {
	LowerBound *int `json:"lowerBound,omitempty" url:"lowerBound,omitempty"`
	UpperBound *int `json:"upperBound,omitempty" url:"upperBound,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UInt32Range) GetLowerBound() *int {
	if u == nil {
		return nil
	}
	return u.LowerBound
}

func (u *UInt32Range) GetUpperBound() *int {
	if u == nil {
		return nil
	}
	return u.UpperBound
}

func (u *UInt32Range) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UInt32Range) UnmarshalJSON(data []byte) error {
	type unmarshaler UInt32Range
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UInt32Range(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UInt32Range) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Visual details associated with the display of an entity in the client.
type VisualDetails struct {
	// The range rings to display around an entity.
	RangeRings *RangeRings `json:"rangeRings,omitempty" url:"rangeRings,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VisualDetails) GetRangeRings() *RangeRings {
	if v == nil {
		return nil
	}
	return v.RangeRings
}

func (v *VisualDetails) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VisualDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler VisualDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VisualDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VisualDetails) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
