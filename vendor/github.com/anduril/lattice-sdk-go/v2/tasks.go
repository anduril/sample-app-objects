// Code generated by Fern. DO NOT EDIT.

package Lattice

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/anduril/lattice-sdk-go/v2/internal"
	time "time"
)

type TaskCreation struct {
	// If non-empty, will set the requested Task ID, otherwise will generate a new random
	// GUID. Will reject if supplied Task ID does not match [A-Za-z0-9_-.]{5,36}.
	TaskID *string `json:"taskId,omitempty" url:"-"`
	// Human readable display name for this Task, should be short (<100 chars).
	DisplayName *string `json:"displayName,omitempty" url:"-"`
	// Longer, free form human readable description of this Task.
	Description *string `json:"description,omitempty" url:"-"`
	// Full set of task parameters.
	Specification *GoogleProtobufAny `json:"specification,omitempty" url:"-"`
	Author        *Principal         `json:"author,omitempty" url:"-"`
	// Any relationships associated with this Task, such as a parent Task or an assignee
	// this Task is designated to for execution.
	Relations *Relations `json:"relations,omitempty" url:"-"`
	// If set, then the service will not trigger execution of this task on an agent. Useful
	// for when ingesting tasks from an external system that is triggering execution of tasks
	// on agents.
	IsExecutedElsewhere *bool `json:"isExecutedElsewhere,omitempty" url:"-"`
	// Indicates an initial set of entities that can be used to execute an entity aware
	// task. For example, an entity Objective, an entity Keep In Zone, etc.
	InitialEntities []*TaskEntity `json:"initialEntities,omitempty" url:"-"`
}

type AgentListener struct {
	// Selector criteria to determine which Agent Tasks the agent receives
	AgentSelector *EntityIDsSelector `json:"agentSelector,omitempty" url:"-"`
}

type TaskQuery struct {
	// If set, returns results starting from the given pageToken.
	PageToken *string `json:"pageToken,omitempty" url:"-"`
	// If present matches Tasks with this parent Task ID.
	// Note: this is mutually exclusive with all other query parameters, i.e., either provide parent Task ID, or
	// any of the remaining parameters, but not both.
	ParentTaskID *string                `json:"parentTaskId,omitempty" url:"-"`
	StatusFilter *TaskQueryStatusFilter `json:"statusFilter,omitempty" url:"-"`
	// If provided, only provides Tasks updated within the time range.
	UpdateTimeRange *TaskQueryUpdateTimeRange `json:"updateTimeRange,omitempty" url:"-"`
}

type AgentRequest struct {
	ExecuteRequest  *ExecuteRequest  `json:"executeRequest,omitempty" url:"executeRequest,omitempty"`
	CancelRequest   *CancelRequest   `json:"cancelRequest,omitempty" url:"cancelRequest,omitempty"`
	CompleteRequest *CompleteRequest `json:"completeRequest,omitempty" url:"completeRequest,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AgentRequest) GetExecuteRequest() *ExecuteRequest {
	if a == nil {
		return nil
	}
	return a.ExecuteRequest
}

func (a *AgentRequest) GetCancelRequest() *CancelRequest {
	if a == nil {
		return nil
	}
	return a.CancelRequest
}

func (a *AgentRequest) GetCompleteRequest() *CompleteRequest {
	if a == nil {
		return nil
	}
	return a.CompleteRequest
}

func (a *AgentRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Allocation contains a list of agents allocated to a Task.
type Allocation struct {
	// Agents actively being utilized in a Task.
	ActiveAgents []*Agent `json:"activeAgents,omitempty" url:"activeAgents,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Allocation) GetActiveAgents() []*Agent {
	if a == nil {
		return nil
	}
	return a.ActiveAgents
}

func (a *Allocation) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Allocation) UnmarshalJSON(data []byte) error {
	type unmarshaler Allocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Allocation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Allocation) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Request to Cancel a Task.
type CancelRequest struct {
	// ID of the Task to cancel.
	TaskID *string `json:"taskId,omitempty" url:"taskId,omitempty"`
	// The assignee of the Task. Useful for agent routing where an endpoint owns multiple agents,
	//
	//	especially onBehalfOf assignees.
	Assignee *Principal `json:"assignee,omitempty" url:"assignee,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CancelRequest) GetTaskID() *string {
	if c == nil {
		return nil
	}
	return c.TaskID
}

func (c *CancelRequest) GetAssignee() *Principal {
	if c == nil {
		return nil
	}
	return c.Assignee
}

func (c *CancelRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Request to Complete a Task.
type CompleteRequest struct {
	// ID of the task to complete.
	TaskID *string `json:"taskId,omitempty" url:"taskId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CompleteRequest) GetTaskID() *string {
	if c == nil {
		return nil
	}
	return c.TaskID
}

func (c *CompleteRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompleteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CompleteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompleteRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompleteRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EntityIDsSelector struct {
	// Receive tasks as an assignee for one or more of the supplied entity ids.
	EntityIDs []string `json:"entityIds,omitempty" url:"entityIds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityIDsSelector) GetEntityIDs() []string {
	if e == nil {
		return nil
	}
	return e.EntityIDs
}

func (e *EntityIDsSelector) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityIDsSelector) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityIDsSelector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityIDsSelector(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityIDsSelector) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Request to execute a Task.
type ExecuteRequest struct {
	// Task to execute.
	Task *Task `json:"task,omitempty" url:"task,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ExecuteRequest) GetTask() *Task {
	if e == nil {
		return nil
	}
	return e.Task
}

func (e *ExecuteRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExecuteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ExecuteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExecuteRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecuteRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Owner designates the entity responsible for writes of Task data.
type Owner struct {
	// Entity ID of the owner.
	EntityID *string `json:"entityId,omitempty" url:"entityId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Owner) GetEntityID() *string {
	if o == nil {
		return nil
	}
	return o.EntityID
}

func (o *Owner) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Owner) UnmarshalJSON(data []byte) error {
	type unmarshaler Owner
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Owner(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Owner) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A Principal is an entity that has authority over this Task.
type Principal struct {
	System *System `json:"system,omitempty" url:"system,omitempty"`
	User   *User   `json:"user,omitempty" url:"user,omitempty"`
	Team   *Team   `json:"team,omitempty" url:"team,omitempty"`
	// The Principal _this_ Principal is acting on behalf of.
	//
	//	Likely only populated once in the nesting (i.e. the "on_behalf_of" Principal would not have another "on_behalf_of" in most cases).
	OnBehalfOf *Principal `json:"onBehalfOf,omitempty" url:"onBehalfOf,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Principal) GetSystem() *System {
	if p == nil {
		return nil
	}
	return p.System
}

func (p *Principal) GetUser() *User {
	if p == nil {
		return nil
	}
	return p.User
}

func (p *Principal) GetTeam() *Team {
	if p == nil {
		return nil
	}
	return p.Team
}

func (p *Principal) GetOnBehalfOf() *Principal {
	if p == nil {
		return nil
	}
	return p.OnBehalfOf
}

func (p *Principal) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Principal) UnmarshalJSON(data []byte) error {
	type unmarshaler Principal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Principal(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Principal) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Relations describes the relationships of this Task, such as assignment, or if the Task has any parents.
type Relations struct {
	// Who or what, if anyone, this Task is currently assigned to.
	Assignee *Principal `json:"assignee,omitempty" url:"assignee,omitempty"`
	// If this Task is a "sub-Task", what is its parent, none if empty.
	ParentTaskID *string `json:"parentTaskId,omitempty" url:"parentTaskId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Relations) GetAssignee() *Principal {
	if r == nil {
		return nil
	}
	return r.Assignee
}

func (r *Relations) GetParentTaskID() *string {
	if r == nil {
		return nil
	}
	return r.ParentTaskID
}

func (r *Relations) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Relations) UnmarshalJSON(data []byte) error {
	type unmarshaler Relations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Relations(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Relations) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Any metadata associated with the replication of a Task.
type Replication struct {
	// Time by which this Task should be assumed to be stale.
	StaleTime *time.Time `json:"staleTime,omitempty" url:"staleTime,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Replication) GetStaleTime() *time.Time {
	if r == nil {
		return nil
	}
	return r.StaleTime
}

func (r *Replication) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Replication) UnmarshalJSON(data []byte) error {
	type embed Replication
	var unmarshaler = struct {
		embed
		StaleTime *internal.DateTime `json:"staleTime,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = Replication(unmarshaler.embed)
	r.StaleTime = unmarshaler.StaleTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Replication) MarshalJSON() ([]byte, error) {
	type embed Replication
	var marshaler = struct {
		embed
		StaleTime *internal.DateTime `json:"staleTime,omitempty"`
	}{
		embed:     embed(*r),
		StaleTime: internal.NewOptionalDateTime(r.StaleTime),
	}
	return json.Marshal(marshaler)
}

func (r *Replication) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// System Principal representing some autonomous system.
type System struct {
	// Name of the service associated with this System.
	ServiceName *string `json:"serviceName,omitempty" url:"serviceName,omitempty"`
	// The Entity ID of the System.
	EntityID *string `json:"entityId,omitempty" url:"entityId,omitempty"`
	// Whether the System Principal (for example, an Asset) can own scheduling.
	//
	//	This means we bypass manager-owned scheduling and defer to the system
	//	Principal to handle scheduling and give us status updates for the Task.
	//	Regardless of the value defined by the client, the Task Manager will
	//	determine and set this value appropriately.
	ManagesOwnScheduling *bool `json:"managesOwnScheduling,omitempty" url:"managesOwnScheduling,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *System) GetServiceName() *string {
	if s == nil {
		return nil
	}
	return s.ServiceName
}

func (s *System) GetEntityID() *string {
	if s == nil {
		return nil
	}
	return s.EntityID
}

func (s *System) GetManagesOwnScheduling() *bool {
	if s == nil {
		return nil
	}
	return s.ManagesOwnScheduling
}

func (s *System) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *System) UnmarshalJSON(data []byte) error {
	type unmarshaler System
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = System(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *System) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A Task is something an agent can be asked to do.
type Task struct {
	// Version of this Task.
	Version *TaskVersion `json:"version,omitempty" url:"version,omitempty"`
	// DEPRECATED: Human readable display name for this Task, should be short (<100 chars).
	DisplayName *string `json:"displayName,omitempty" url:"displayName,omitempty"`
	// Full Task parameterization.
	Specification *GoogleProtobufAny `json:"specification,omitempty" url:"specification,omitempty"`
	// Records who created this Task. This field will not change after the Task has been created.
	CreatedBy *Principal `json:"createdBy,omitempty" url:"createdBy,omitempty"`
	// Records who updated this Task last.
	LastUpdatedBy *Principal `json:"lastUpdatedBy,omitempty" url:"lastUpdatedBy,omitempty"`
	// Records the time of last update.
	LastUpdateTime *time.Time `json:"lastUpdateTime,omitempty" url:"lastUpdateTime,omitempty"`
	// The status of this Task.
	Status *TaskStatus `json:"status,omitempty" url:"status,omitempty"`
	// If the Task has been scheduled to execute, what time it should execute at.
	ScheduledTime *time.Time `json:"scheduledTime,omitempty" url:"scheduledTime,omitempty"`
	// Any related Tasks associated with this, typically includes an assignee for this Task and/or a parent.
	Relations *Relations `json:"relations,omitempty" url:"relations,omitempty"`
	// Longer, free form human readable description of this Task
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// If set, execution of this Task is managed elsewhere, not by Task Manager.
	//
	//	In other words, Task manager will not attempt to update the assigned agent with execution instructions.
	IsExecutedElsewhere *bool `json:"isExecutedElsewhere,omitempty" url:"isExecutedElsewhere,omitempty"`
	// Time of Task creation.
	CreateTime *time.Time `json:"createTime,omitempty" url:"createTime,omitempty"`
	// If populated, designates this to be a replicated Task.
	Replication *Replication `json:"replication,omitempty" url:"replication,omitempty"`
	// If populated, indicates an initial set of entities that can be used to execute an entity aware task
	//
	//	For example, an entity Objective, an entity Keep In Zone, etc.
	//	These will not be updated during execution. If a taskable agent needs continuous updates on the entities from the
	//	COP, can call entity-manager, or use an AlternateId escape hatch.
	InitialEntities []*TaskEntity `json:"initialEntities,omitempty" url:"initialEntities,omitempty"`
	// The networked owner of this Task. It is used to ensure that linear writes occur on the node responsible
	//
	//	for replication of task data to other nodes running Task Manager.
	Owner *Owner `json:"owner,omitempty" url:"owner,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Task) GetVersion() *TaskVersion {
	if t == nil {
		return nil
	}
	return t.Version
}

func (t *Task) GetDisplayName() *string {
	if t == nil {
		return nil
	}
	return t.DisplayName
}

func (t *Task) GetSpecification() *GoogleProtobufAny {
	if t == nil {
		return nil
	}
	return t.Specification
}

func (t *Task) GetCreatedBy() *Principal {
	if t == nil {
		return nil
	}
	return t.CreatedBy
}

func (t *Task) GetLastUpdatedBy() *Principal {
	if t == nil {
		return nil
	}
	return t.LastUpdatedBy
}

func (t *Task) GetLastUpdateTime() *time.Time {
	if t == nil {
		return nil
	}
	return t.LastUpdateTime
}

func (t *Task) GetStatus() *TaskStatus {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *Task) GetScheduledTime() *time.Time {
	if t == nil {
		return nil
	}
	return t.ScheduledTime
}

func (t *Task) GetRelations() *Relations {
	if t == nil {
		return nil
	}
	return t.Relations
}

func (t *Task) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *Task) GetIsExecutedElsewhere() *bool {
	if t == nil {
		return nil
	}
	return t.IsExecutedElsewhere
}

func (t *Task) GetCreateTime() *time.Time {
	if t == nil {
		return nil
	}
	return t.CreateTime
}

func (t *Task) GetReplication() *Replication {
	if t == nil {
		return nil
	}
	return t.Replication
}

func (t *Task) GetInitialEntities() []*TaskEntity {
	if t == nil {
		return nil
	}
	return t.InitialEntities
}

func (t *Task) GetOwner() *Owner {
	if t == nil {
		return nil
	}
	return t.Owner
}

func (t *Task) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Task) UnmarshalJSON(data []byte) error {
	type embed Task
	var unmarshaler = struct {
		embed
		LastUpdateTime *internal.DateTime `json:"lastUpdateTime,omitempty"`
		ScheduledTime  *internal.DateTime `json:"scheduledTime,omitempty"`
		CreateTime     *internal.DateTime `json:"createTime,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Task(unmarshaler.embed)
	t.LastUpdateTime = unmarshaler.LastUpdateTime.TimePtr()
	t.ScheduledTime = unmarshaler.ScheduledTime.TimePtr()
	t.CreateTime = unmarshaler.CreateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Task) MarshalJSON() ([]byte, error) {
	type embed Task
	var marshaler = struct {
		embed
		LastUpdateTime *internal.DateTime `json:"lastUpdateTime,omitempty"`
		ScheduledTime  *internal.DateTime `json:"scheduledTime,omitempty"`
		CreateTime     *internal.DateTime `json:"createTime,omitempty"`
	}{
		embed:          embed(*t),
		LastUpdateTime: internal.NewOptionalDateTime(t.LastUpdateTime),
		ScheduledTime:  internal.NewOptionalDateTime(t.ScheduledTime),
		CreateTime:     internal.NewOptionalDateTime(t.CreateTime),
	}
	return json.Marshal(marshaler)
}

func (t *Task) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Wrapper of an entity passed in Tasking, used to hold an additional information, and as a future extension point.
type TaskEntity struct {
	// The wrapped entity-manager entity.
	Entity *Entity `json:"entity,omitempty" url:"entity,omitempty"`
	// Indicates that this entity was generated from a snapshot of a live entity.
	Snapshot *bool `json:"snapshot,omitempty" url:"snapshot,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaskEntity) GetEntity() *Entity {
	if t == nil {
		return nil
	}
	return t.Entity
}

func (t *TaskEntity) GetSnapshot() *bool {
	if t == nil {
		return nil
	}
	return t.Snapshot
}

func (t *TaskEntity) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaskEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler TaskEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaskEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaskEntity) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// TaskError contains an error code and message typically associated to a Task.
type TaskError struct {
	// Error code for Task error.
	Code *TaskErrorCode `json:"code,omitempty" url:"code,omitempty"`
	// Descriptive human-readable string regarding this error.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Any additional details regarding this error.
	ErrorDetails *GoogleProtobufAny `json:"errorDetails,omitempty" url:"errorDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaskError) GetCode() *TaskErrorCode {
	if t == nil {
		return nil
	}
	return t.Code
}

func (t *TaskError) GetMessage() *string {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *TaskError) GetErrorDetails() *GoogleProtobufAny {
	if t == nil {
		return nil
	}
	return t.ErrorDetails
}

func (t *TaskError) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaskError) UnmarshalJSON(data []byte) error {
	type unmarshaler TaskError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaskError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaskError) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Error code for Task error.
type TaskErrorCode string

const (
	TaskErrorCodeErrorCodeInvalid   TaskErrorCode = "ERROR_CODE_INVALID"
	TaskErrorCodeErrorCodeCancelled TaskErrorCode = "ERROR_CODE_CANCELLED"
	TaskErrorCodeErrorCodeRejected  TaskErrorCode = "ERROR_CODE_REJECTED"
	TaskErrorCodeErrorCodeTimeout   TaskErrorCode = "ERROR_CODE_TIMEOUT"
	TaskErrorCodeErrorCodeFailed    TaskErrorCode = "ERROR_CODE_FAILED"
)

func NewTaskErrorCodeFromString(s string) (TaskErrorCode, error) {
	switch s {
	case "ERROR_CODE_INVALID":
		return TaskErrorCodeErrorCodeInvalid, nil
	case "ERROR_CODE_CANCELLED":
		return TaskErrorCodeErrorCodeCancelled, nil
	case "ERROR_CODE_REJECTED":
		return TaskErrorCodeErrorCodeRejected, nil
	case "ERROR_CODE_TIMEOUT":
		return TaskErrorCodeErrorCodeTimeout, nil
	case "ERROR_CODE_FAILED":
		return TaskErrorCodeErrorCodeFailed, nil
	}
	var t TaskErrorCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaskErrorCode) Ptr() *TaskErrorCode {
	return &t
}

type TaskQueryResults struct {
	Tasks []*Task `json:"tasks,omitempty" url:"tasks,omitempty"`
	// Incomplete results can be detected by a non-empty nextPageToken field in the query results. In order to retrieve
	// the next page, perform the exact same request as previously and append a pageToken field with the value of
	// nextPageToken from the previous page. A new nextPageToken is provided on the following pages until all the
	// results are retrieved.
	NextPageToken *string `json:"nextPageToken,omitempty" url:"nextPageToken,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaskQueryResults) GetTasks() []*Task {
	if t == nil {
		return nil
	}
	return t.Tasks
}

func (t *TaskQueryResults) GetNextPageToken() *string {
	if t == nil {
		return nil
	}
	return t.NextPageToken
}

func (t *TaskQueryResults) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaskQueryResults) UnmarshalJSON(data []byte) error {
	type unmarshaler TaskQueryResults
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaskQueryResults(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaskQueryResults) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// TaskStatus is contains information regarding the status of a Task at any given time. Can include related information
//
//	such as any progress towards Task completion, or any associated results if Task completed.
type TaskStatus struct {
	// Status of the Task.
	Status *TaskStatusStatus `json:"status,omitempty" url:"status,omitempty"`
	// Any errors associated with the Task.
	TaskError *TaskError `json:"taskError,omitempty" url:"taskError,omitempty"`
	// Any incremental progress on the Task, should be from the tasks/v* /progress folder.
	Progress *GoogleProtobufAny `json:"progress,omitempty" url:"progress,omitempty"`
	// Any final result of the Task, should be from tasks/v* /result folder.
	Result *GoogleProtobufAny `json:"result,omitempty" url:"result,omitempty"`
	// Time the Task began execution, may not be known even for executing Tasks.
	StartTime *time.Time `json:"startTime,omitempty" url:"startTime,omitempty"`
	// Any estimate for how the Task will progress, should be from tasks/v* /estimates folder.
	Estimate *GoogleProtobufAny `json:"estimate,omitempty" url:"estimate,omitempty"`
	// Any allocated agents of the Task.
	Allocation *Allocation `json:"allocation,omitempty" url:"allocation,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaskStatus) GetStatus() *TaskStatusStatus {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TaskStatus) GetTaskError() *TaskError {
	if t == nil {
		return nil
	}
	return t.TaskError
}

func (t *TaskStatus) GetProgress() *GoogleProtobufAny {
	if t == nil {
		return nil
	}
	return t.Progress
}

func (t *TaskStatus) GetResult() *GoogleProtobufAny {
	if t == nil {
		return nil
	}
	return t.Result
}

func (t *TaskStatus) GetStartTime() *time.Time {
	if t == nil {
		return nil
	}
	return t.StartTime
}

func (t *TaskStatus) GetEstimate() *GoogleProtobufAny {
	if t == nil {
		return nil
	}
	return t.Estimate
}

func (t *TaskStatus) GetAllocation() *Allocation {
	if t == nil {
		return nil
	}
	return t.Allocation
}

func (t *TaskStatus) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaskStatus) UnmarshalJSON(data []byte) error {
	type embed TaskStatus
	var unmarshaler = struct {
		embed
		StartTime *internal.DateTime `json:"startTime,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TaskStatus(unmarshaler.embed)
	t.StartTime = unmarshaler.StartTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaskStatus) MarshalJSON() ([]byte, error) {
	type embed TaskStatus
	var marshaler = struct {
		embed
		StartTime *internal.DateTime `json:"startTime,omitempty"`
	}{
		embed:     embed(*t),
		StartTime: internal.NewOptionalDateTime(t.StartTime),
	}
	return json.Marshal(marshaler)
}

func (t *TaskStatus) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Status of the Task.
type TaskStatusStatus string

const (
	TaskStatusStatusStatusInvalid            TaskStatusStatus = "STATUS_INVALID"
	TaskStatusStatusStatusCreated            TaskStatusStatus = "STATUS_CREATED"
	TaskStatusStatusStatusScheduledInManager TaskStatusStatus = "STATUS_SCHEDULED_IN_MANAGER"
	TaskStatusStatusStatusSent               TaskStatusStatus = "STATUS_SENT"
	TaskStatusStatusStatusMachineReceipt     TaskStatusStatus = "STATUS_MACHINE_RECEIPT"
	TaskStatusStatusStatusAck                TaskStatusStatus = "STATUS_ACK"
	TaskStatusStatusStatusWilco              TaskStatusStatus = "STATUS_WILCO"
	TaskStatusStatusStatusExecuting          TaskStatusStatus = "STATUS_EXECUTING"
	TaskStatusStatusStatusWaitingForUpdate   TaskStatusStatus = "STATUS_WAITING_FOR_UPDATE"
	TaskStatusStatusStatusDoneOk             TaskStatusStatus = "STATUS_DONE_OK"
	TaskStatusStatusStatusDoneNotOk          TaskStatusStatus = "STATUS_DONE_NOT_OK"
	TaskStatusStatusStatusReplaced           TaskStatusStatus = "STATUS_REPLACED"
	TaskStatusStatusStatusCancelRequested    TaskStatusStatus = "STATUS_CANCEL_REQUESTED"
	TaskStatusStatusStatusCompleteRequested  TaskStatusStatus = "STATUS_COMPLETE_REQUESTED"
	TaskStatusStatusStatusVersionRejected    TaskStatusStatus = "STATUS_VERSION_REJECTED"
)

func NewTaskStatusStatusFromString(s string) (TaskStatusStatus, error) {
	switch s {
	case "STATUS_INVALID":
		return TaskStatusStatusStatusInvalid, nil
	case "STATUS_CREATED":
		return TaskStatusStatusStatusCreated, nil
	case "STATUS_SCHEDULED_IN_MANAGER":
		return TaskStatusStatusStatusScheduledInManager, nil
	case "STATUS_SENT":
		return TaskStatusStatusStatusSent, nil
	case "STATUS_MACHINE_RECEIPT":
		return TaskStatusStatusStatusMachineReceipt, nil
	case "STATUS_ACK":
		return TaskStatusStatusStatusAck, nil
	case "STATUS_WILCO":
		return TaskStatusStatusStatusWilco, nil
	case "STATUS_EXECUTING":
		return TaskStatusStatusStatusExecuting, nil
	case "STATUS_WAITING_FOR_UPDATE":
		return TaskStatusStatusStatusWaitingForUpdate, nil
	case "STATUS_DONE_OK":
		return TaskStatusStatusStatusDoneOk, nil
	case "STATUS_DONE_NOT_OK":
		return TaskStatusStatusStatusDoneNotOk, nil
	case "STATUS_REPLACED":
		return TaskStatusStatusStatusReplaced, nil
	case "STATUS_CANCEL_REQUESTED":
		return TaskStatusStatusStatusCancelRequested, nil
	case "STATUS_COMPLETE_REQUESTED":
		return TaskStatusStatusStatusCompleteRequested, nil
	case "STATUS_VERSION_REJECTED":
		return TaskStatusStatusStatusVersionRejected, nil
	}
	var t TaskStatusStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaskStatusStatus) Ptr() *TaskStatusStatus {
	return &t
}

// Version of a Task.
type TaskVersion struct {
	// The unique ID for this Task.
	TaskID *string `json:"taskId,omitempty" url:"taskId,omitempty"`
	// Increments on definition (i.e. not TaskStatus) change. 0 is unset, starts at 1 on creation.
	DefinitionVersion *int `json:"definitionVersion,omitempty" url:"definitionVersion,omitempty"`
	// Increments on changes to TaskStatus. 0 is unset, starts at 1 on creation.
	StatusVersion *int `json:"statusVersion,omitempty" url:"statusVersion,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaskVersion) GetTaskID() *string {
	if t == nil {
		return nil
	}
	return t.TaskID
}

func (t *TaskVersion) GetDefinitionVersion() *int {
	if t == nil {
		return nil
	}
	return t.DefinitionVersion
}

func (t *TaskVersion) GetStatusVersion() *int {
	if t == nil {
		return nil
	}
	return t.StatusVersion
}

func (t *TaskVersion) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaskVersion) UnmarshalJSON(data []byte) error {
	type unmarshaler TaskVersion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaskVersion(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaskVersion) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// A User Principal representing a human.
type User struct {
	// The User ID associated with this User.
	UserID *string `json:"userId,omitempty" url:"userId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *User) GetUserID() *string {
	if u == nil {
		return nil
	}
	return u.UserID
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type unmarshaler User
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = User(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type TaskQueryStatusFilter struct {
	// Status of the Task to filter by, inclusive.
	Status *TaskQueryStatusFilterStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaskQueryStatusFilter) GetStatus() *TaskQueryStatusFilterStatus {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TaskQueryStatusFilter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaskQueryStatusFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler TaskQueryStatusFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaskQueryStatusFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaskQueryStatusFilter) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Status of the Task to filter by, inclusive.
type TaskQueryStatusFilterStatus string

const (
	TaskQueryStatusFilterStatusStatusInvalid            TaskQueryStatusFilterStatus = "STATUS_INVALID"
	TaskQueryStatusFilterStatusStatusCreated            TaskQueryStatusFilterStatus = "STATUS_CREATED"
	TaskQueryStatusFilterStatusStatusScheduledInManager TaskQueryStatusFilterStatus = "STATUS_SCHEDULED_IN_MANAGER"
	TaskQueryStatusFilterStatusStatusSent               TaskQueryStatusFilterStatus = "STATUS_SENT"
	TaskQueryStatusFilterStatusStatusMachineReceipt     TaskQueryStatusFilterStatus = "STATUS_MACHINE_RECEIPT"
	TaskQueryStatusFilterStatusStatusAck                TaskQueryStatusFilterStatus = "STATUS_ACK"
	TaskQueryStatusFilterStatusStatusWilco              TaskQueryStatusFilterStatus = "STATUS_WILCO"
	TaskQueryStatusFilterStatusStatusExecuting          TaskQueryStatusFilterStatus = "STATUS_EXECUTING"
	TaskQueryStatusFilterStatusStatusWaitingForUpdate   TaskQueryStatusFilterStatus = "STATUS_WAITING_FOR_UPDATE"
	TaskQueryStatusFilterStatusStatusDoneOk             TaskQueryStatusFilterStatus = "STATUS_DONE_OK"
	TaskQueryStatusFilterStatusStatusDoneNotOk          TaskQueryStatusFilterStatus = "STATUS_DONE_NOT_OK"
	TaskQueryStatusFilterStatusStatusReplaced           TaskQueryStatusFilterStatus = "STATUS_REPLACED"
	TaskQueryStatusFilterStatusStatusCancelRequested    TaskQueryStatusFilterStatus = "STATUS_CANCEL_REQUESTED"
	TaskQueryStatusFilterStatusStatusCompleteRequested  TaskQueryStatusFilterStatus = "STATUS_COMPLETE_REQUESTED"
	TaskQueryStatusFilterStatusStatusVersionRejected    TaskQueryStatusFilterStatus = "STATUS_VERSION_REJECTED"
)

func NewTaskQueryStatusFilterStatusFromString(s string) (TaskQueryStatusFilterStatus, error) {
	switch s {
	case "STATUS_INVALID":
		return TaskQueryStatusFilterStatusStatusInvalid, nil
	case "STATUS_CREATED":
		return TaskQueryStatusFilterStatusStatusCreated, nil
	case "STATUS_SCHEDULED_IN_MANAGER":
		return TaskQueryStatusFilterStatusStatusScheduledInManager, nil
	case "STATUS_SENT":
		return TaskQueryStatusFilterStatusStatusSent, nil
	case "STATUS_MACHINE_RECEIPT":
		return TaskQueryStatusFilterStatusStatusMachineReceipt, nil
	case "STATUS_ACK":
		return TaskQueryStatusFilterStatusStatusAck, nil
	case "STATUS_WILCO":
		return TaskQueryStatusFilterStatusStatusWilco, nil
	case "STATUS_EXECUTING":
		return TaskQueryStatusFilterStatusStatusExecuting, nil
	case "STATUS_WAITING_FOR_UPDATE":
		return TaskQueryStatusFilterStatusStatusWaitingForUpdate, nil
	case "STATUS_DONE_OK":
		return TaskQueryStatusFilterStatusStatusDoneOk, nil
	case "STATUS_DONE_NOT_OK":
		return TaskQueryStatusFilterStatusStatusDoneNotOk, nil
	case "STATUS_REPLACED":
		return TaskQueryStatusFilterStatusStatusReplaced, nil
	case "STATUS_CANCEL_REQUESTED":
		return TaskQueryStatusFilterStatusStatusCancelRequested, nil
	case "STATUS_COMPLETE_REQUESTED":
		return TaskQueryStatusFilterStatusStatusCompleteRequested, nil
	case "STATUS_VERSION_REJECTED":
		return TaskQueryStatusFilterStatusStatusVersionRejected, nil
	}
	var t TaskQueryStatusFilterStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaskQueryStatusFilterStatus) Ptr() *TaskQueryStatusFilterStatus {
	return &t
}

// If provided, only provides Tasks updated within the time range.
type TaskQueryUpdateTimeRange struct {
	// If provided, returns Tasks only updated after this time.
	StartTime *string `json:"startTime,omitempty" url:"startTime,omitempty"`
	// If provided, returns Tasks only updated before this time.
	EndTime *string `json:"endTime,omitempty" url:"endTime,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaskQueryUpdateTimeRange) GetStartTime() *string {
	if t == nil {
		return nil
	}
	return t.StartTime
}

func (t *TaskQueryUpdateTimeRange) GetEndTime() *string {
	if t == nil {
		return nil
	}
	return t.EndTime
}

func (t *TaskQueryUpdateTimeRange) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaskQueryUpdateTimeRange) UnmarshalJSON(data []byte) error {
	type unmarshaler TaskQueryUpdateTimeRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaskQueryUpdateTimeRange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaskQueryUpdateTimeRange) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TaskStatusUpdate struct {
	// The status version of the task to update. This version number increments to indicate the task's
	// current stage in its status lifecycle. Specifically, whenever a task's status updates, the status
	// version increments by one. Any status updates received with a lower status version number than what
	// is known are considered stale and ignored.
	StatusVersion *int `json:"statusVersion,omitempty" url:"-"`
	// The new status of the task.
	NewStatus *TaskStatus `json:"newStatus,omitempty" url:"-"`
	Author    *Principal  `json:"author,omitempty" url:"-"`
}
