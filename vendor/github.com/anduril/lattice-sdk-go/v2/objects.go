// Code generated by Fern. DO NOT EDIT.

package Lattice

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/anduril/lattice-sdk-go/v2/internal"
	time "time"
)

type GetObjectRequest struct {
	// If set, Lattice will compress the response using the specified compression method. If the header is not defined, or the compression method is set to `identity`, no compression will be applied to the response.
	AcceptEncoding *GetObjectRequestAcceptEncoding `json:"-" url:"-"`
}

type ListObjectsRequest struct {
	// Filters the objects based on the specified prefix path. If no path is specified, all objects are returned.
	Prefix *string `json:"-" url:"prefix,omitempty"`
	// Sets the age for the oldest objects to query across the environment.
	SinceTimestamp *time.Time `json:"-" url:"sinceTimestamp,omitempty"`
	// Base64 and URL-encoded cursor returned by the service to continue paging.
	PageToken *string `json:"-" url:"pageToken,omitempty"`
	// Lists objects across all environment nodes in a Lattice Mesh.
	AllObjectsInMesh *bool `json:"-" url:"allObjectsInMesh,omitempty"`
}

type ContentIdentifier struct {
	// A valid path must not contain the following:
	// - Spaces or Tabs
	// - Special characters other than underscore (_), dash (-), period (.) and slash (/)
	// - Non-ASCII characters such as accents or symbols
	// Paths must not start with a leading space.
	Path string `json:"path" url:"path"`
	// The SHA-256 checksum of this object.
	Checksum string `json:"checksum" url:"checksum"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContentIdentifier) GetPath() string {
	if c == nil {
		return ""
	}
	return c.Path
}

func (c *ContentIdentifier) GetChecksum() string {
	if c == nil {
		return ""
	}
	return c.Checksum
}

func (c *ContentIdentifier) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContentIdentifier) UnmarshalJSON(data []byte) error {
	type unmarshaler ContentIdentifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContentIdentifier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContentIdentifier) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ListResponse struct {
	PathMetadatas []*PathMetadata `json:"path_metadatas" url:"path_metadatas"`
	NextPageToken *string         `json:"next_page_token,omitempty" url:"next_page_token,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListResponse) GetPathMetadatas() []*PathMetadata {
	if l == nil {
		return nil
	}
	return l.PathMetadatas
}

func (l *ListResponse) GetNextPageToken() *string {
	if l == nil {
		return nil
	}
	return l.NextPageToken
}

func (l *ListResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type PathMetadata struct {
	ContentIdentifier *ContentIdentifier `json:"content_identifier" url:"content_identifier"`
	SizeBytes         int64              `json:"size_bytes" url:"size_bytes"`
	LastUpdatedAt     time.Time          `json:"last_updated_at" url:"last_updated_at"`
	ExpiryTime        *time.Time         `json:"expiry_time,omitempty" url:"expiry_time,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PathMetadata) GetContentIdentifier() *ContentIdentifier {
	if p == nil {
		return nil
	}
	return p.ContentIdentifier
}

func (p *PathMetadata) GetSizeBytes() int64 {
	if p == nil {
		return 0
	}
	return p.SizeBytes
}

func (p *PathMetadata) GetLastUpdatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.LastUpdatedAt
}

func (p *PathMetadata) GetExpiryTime() *time.Time {
	if p == nil {
		return nil
	}
	return p.ExpiryTime
}

func (p *PathMetadata) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PathMetadata) UnmarshalJSON(data []byte) error {
	type embed PathMetadata
	var unmarshaler = struct {
		embed
		LastUpdatedAt *internal.DateTime `json:"last_updated_at"`
		ExpiryTime    *internal.DateTime `json:"expiry_time,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PathMetadata(unmarshaler.embed)
	p.LastUpdatedAt = unmarshaler.LastUpdatedAt.Time()
	p.ExpiryTime = unmarshaler.ExpiryTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PathMetadata) MarshalJSON() ([]byte, error) {
	type embed PathMetadata
	var marshaler = struct {
		embed
		LastUpdatedAt *internal.DateTime `json:"last_updated_at"`
		ExpiryTime    *internal.DateTime `json:"expiry_time,omitempty"`
	}{
		embed:         embed(*p),
		LastUpdatedAt: internal.NewDateTime(p.LastUpdatedAt),
		ExpiryTime:    internal.NewOptionalDateTime(p.ExpiryTime),
	}
	return json.Marshal(marshaler)
}

func (p *PathMetadata) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type GetObjectRequestAcceptEncoding string

const (
	GetObjectRequestAcceptEncodingIdentity GetObjectRequestAcceptEncoding = "identity"
	GetObjectRequestAcceptEncodingZstd     GetObjectRequestAcceptEncoding = "zstd"
)

func NewGetObjectRequestAcceptEncodingFromString(s string) (GetObjectRequestAcceptEncoding, error) {
	switch s {
	case "identity":
		return GetObjectRequestAcceptEncodingIdentity, nil
	case "zstd":
		return GetObjectRequestAcceptEncodingZstd, nil
	}
	var t GetObjectRequestAcceptEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetObjectRequestAcceptEncoding) Ptr() *GetObjectRequestAcceptEncoding {
	return &g
}
